import { ApolloClient, InMemoryCache } from "@apollo/client"
import { ADD_FLASH_CARD_MUTATION } from "./graphql/mutations/addFlashCard.mutation"
import { storage, storageReady } from "./utils/secure-storage"

export {}

const DROPLET_SERVER_ADDRESS = "https://api.bundai.app/graphql"
const LOCAL_ADDRESS = "http://localhost:3000/graphql"

console.log("Live now; make now always the most precious time. Now will never come again.")

// ===== CENTRALIZED STATE MANAGEMENT =====
interface WordCardStyles {
  backgroundColor: string
  textColor: string
  fontSize: number
  borderRadius: number
  borderColor: string
  wordFontSize: number
}

interface ExtensionState {
  extensionEnabled: boolean
  useAutoGeneratedSubtitles: boolean
  wordCardStyles: WordCardStyles
}

const defaultWordCardStyles: WordCardStyles = {
  backgroundColor: "#fde047",
  textColor: "#000000",
  fontSize: 18,
  borderRadius: 24,
  borderColor: "#a16207",
  wordFontSize: 48
}

let extensionState: ExtensionState = {
  extensionEnabled: true,
  useAutoGeneratedSubtitles: false,
  wordCardStyles: { ...defaultWordCardStyles }
}

// Track if state has been initialized from storage
let stateInitialized = false
let stateInitPromise: Promise<void> | null = null

// Initialize state from storage on startup
async function initializeState() {
  if (stateInitialized) return
  
  try {
    await storageReady
    
    // Load extensionEnabled
    const enabledValue = await storage.get("extensionEnabled")
    extensionState.extensionEnabled = typeof enabledValue === "boolean" ? enabledValue : true
    
    // Load useAutoGeneratedSubtitles
    const autoGenValue = await storage.get("useAutoGeneratedSubtitles")
    extensionState.useAutoGeneratedSubtitles = typeof autoGenValue === "boolean" ? autoGenValue : false
    
    // Load wordCardStyles
    const stylesValue = await storage.get("wordCardStyles")
    extensionState.wordCardStyles = (stylesValue && typeof stylesValue === "object") 
      ? { ...defaultWordCardStyles, ...stylesValue } 
      : { ...defaultWordCardStyles }
    
    stateInitialized = true
    console.log("[Background] State initialized:", extensionState)
  } catch (error) {
    console.error("[Background] Failed to initialize state:", error)
    stateInitialized = true // Mark as initialized even on error to avoid hanging
  }
}

// Ensure state is initialized before responding
async function ensureStateInitialized() {
  if (stateInitialized) return
  if (stateInitPromise) {
    await stateInitPromise
  } else {
    stateInitPromise = initializeState()
    await stateInitPromise
  }
}

// Broadcast state changes to all YouTube tabs
async function broadcastStateToYouTubeTabs() {
  try {
    const tabs = await chrome.tabs.query({ url: "*://*.youtube.com/*" })
    
    for (const tab of tabs) {
      if (!tab.id) continue
      
      // Send to custom subtitle container
      chrome.tabs.sendMessage(tab.id, {
        action: "setExtensionEnabled",
        enabled: extensionState.extensionEnabled && !extensionState.useAutoGeneratedSubtitles
      }).catch(() => {
        // Content script might not be loaded yet, ignore
      })
      
      // Send to YouTube manipulator
      chrome.tabs.sendMessage(tab.id, {
        action: "setUseAutoGeneratedSubtitles",
        useAutoGenerated: extensionState.extensionEnabled && extensionState.useAutoGeneratedSubtitles
      }).catch(() => {
        // Content script might not be loaded yet, ignore
      })
      
      // Send wordCardStyles
      chrome.tabs.sendMessage(tab.id, {
        action: "setWordCardStyles",
        styles: extensionState.wordCardStyles
      }).catch(() => {
        // Content script might not be loaded yet, ignore
      })
    }
    
    console.log("[Background] Broadcast state to", tabs.length, "tabs")
  } catch (error) {
    console.error("[Background] Failed to broadcast state:", error)
  }
}

// ===== MESSAGE HANDLERS =====
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // Flash card handling
  if (message.action === "addFlashCard") {
    handleAddFlashCard(message.data)
      .then((result) => sendResponse({ success: true, data: result }))
      .catch((error) => sendResponse({ success: false, error: error.message }))
    return true
  }

  // Extension enabled state
  if (message.action === "getExtensionState") {
    ensureStateInitialized().then(() => {
      sendResponse({ enabled: extensionState.extensionEnabled })
    })
    return true
  }

  if (message.action === "setExtensionEnabled") {
    ensureStateInitialized().then(() => {
      extensionState.extensionEnabled = message.enabled
      
      // Persist to storage
      storage.set("extensionEnabled", message.enabled).catch(console.error)
      
      // Broadcast to all tabs
      broadcastStateToYouTubeTabs()
      
      sendResponse({ success: true })
    })
    return true
  }

  // Auto-generated subtitles state
  if (message.action === "getUseAutoGeneratedSubtitles") {
    ensureStateInitialized().then(() => {
      console.log("[Background] Responding to getUseAutoGeneratedSubtitles:", extensionState)
      sendResponse({ 
        useAutoGenerated: extensionState.useAutoGeneratedSubtitles,
        extensionEnabled: extensionState.extensionEnabled
      })
    })
    return true
  }

  if (message.action === "setUseAutoGeneratedSubtitles") {
    ensureStateInitialized().then(() => {
      extensionState.useAutoGeneratedSubtitles = message.useAutoGenerated
      
      // Persist to storage
      storage.set("useAutoGeneratedSubtitles", message.useAutoGenerated).catch(console.error)
      
      // Broadcast to all tabs
      broadcastStateToYouTubeTabs()
      
      sendResponse({ success: true })
    })
    return true
  }

  // WordCard styles state
  if (message.action === "getWordCardStyles") {
    ensureStateInitialized().then(() => {
      sendResponse({ styles: extensionState.wordCardStyles })
    })
    return true
  }

  if (message.action === "setWordCardStyles") {
    ensureStateInitialized().then(() => {
      extensionState.wordCardStyles = { ...defaultWordCardStyles, ...message.styles }
      
      // Persist to storage
      storage.set("wordCardStyles", extensionState.wordCardStyles).catch(console.error)
      
      // Broadcast to all tabs
      broadcastStateToYouTubeTabs()
      
      sendResponse({ success: true })
    })
    return true
  }

  return false
})

// ===== FLASH CARD HANDLERS =====
async function handleAddFlashCard(flashCardData) {
  console.log("[Background] handleAddFlashCard received:", flashCardData)
  const { userId, kanjiName, hiragana, meanings, quizAnswers, source } = flashCardData
  console.log("[Background] Extracted source:", source)

  try {
    await storageReady
    const token = await storage.get("token")

    if (!token) {
      throw new Error("Authentication token not found")
    }

    const authenticatedClient = new ApolloClient({
      uri: DROPLET_SERVER_ADDRESS,
      cache: new InMemoryCache({
        dataIdFromObject: (o) => (o.id != null ? String(o.id) : undefined)
      }),
      headers: {
        authorization: `Bearer ${token}`,
        "content-type": "application/json"
      }
    })

    const variables = {
      userId,
      kanjiName,
      hiragana,
      meanings,
      quizAnswers,
      source: source || "extension"
    }
    console.log("[Background] Apollo mutation variables:", variables)
    
    const result = await authenticatedClient.mutate({
      mutation: ADD_FLASH_CARD_MUTATION,
      variables
    })

    console.log("Background script: Flashcard added successfully", result.data)
    return result.data
  } catch (error) {
    console.error("Background script addFlashCard error:", error)

    try {
      return await handleAddFlashCardDirect(flashCardData)
    } catch (directError) {
      console.error("Direct fetch fallback also failed:", directError)
      throw error
    }
  }
}

async function handleAddFlashCardDirect(flashCardData) {
  const { userId, kanjiName, hiragana, meanings, quizAnswers, source } = flashCardData

  await storageReady
  const token = await storage.get("token")

  if (!token) {
    throw new Error("Authentication token not found")
  }

  const response = await fetch(DROPLET_SERVER_ADDRESS, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`
    },
    body: JSON.stringify({
      query: `
        mutation AddFlashCard($userId: ID!, $kanjiName: String!, $hiragana: String!, $meanings: [String!]!, $quizAnswers: [String!]!, $source: String) {
          addFlashCard(userId: $userId, kanjiName: $kanjiName, hiragana: $hiragana, meanings: $meanings, quizAnswers: $quizAnswers, source: $source) {
            _id
            kanjiName
            hiragana
            meanings
            quizAnswers
          }
        }
      `,
      variables: {
        userId,
        kanjiName,
        hiragana,
        meanings,
        quizAnswers,
        source: source || "extension"
      }
    })
  })

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }

  const result = await response.json()

  if (result.errors) {
    throw new Error(result.errors[0].message)
  }

  console.log("Background script: Direct fetch successful", result.data)
  return result.data.addFlashCard
}

// ===== LIFECYCLE HANDLERS =====
chrome.runtime.onInstalled.addListener(() => {
  console.log("Bundai Extension installed/updated")
  initializeState()
})

chrome.runtime.onStartup.addListener(() => {
  console.log("Bundai Extension started")
  initializeState()
})

chrome.action.onClicked.addListener((tab) => {
  console.log("Extension icon clicked on tab:", tab.url)
})

// Listen for tab updates to broadcast state when content scripts load
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  // When a YouTube page finishes loading, broadcast current state
  if (changeInfo.status === 'complete' && tab.url && tab.url.includes('youtube.com')) {
    console.log("[Background] YouTube tab loaded, broadcasting state")
    // Small delay to ensure content scripts are ready
    setTimeout(() => {
      chrome.tabs.sendMessage(tabId, {
        action: "setExtensionEnabled",
        enabled: extensionState.extensionEnabled && !extensionState.useAutoGeneratedSubtitles
      }).catch(() => {
        // Content script might not be loaded yet, ignore
      })
      
      chrome.tabs.sendMessage(tabId, {
        action: "setUseAutoGeneratedSubtitles",
        useAutoGenerated: extensionState.extensionEnabled && extensionState.useAutoGeneratedSubtitles
      }).catch(() => {
        // Content script might not be loaded yet, ignore
      })
      
      chrome.tabs.sendMessage(tabId, {
        action: "setWordCardStyles",
        styles: extensionState.wordCardStyles
      }).catch(() => {
        // Content script might not be loaded yet, ignore
      })
    }, 500)
  }
})

// Initialize state immediately
stateInitPromise = initializeState()
stateInitPromise.then(() => {
  console.log("[Background] Ready to serve requests")
})
