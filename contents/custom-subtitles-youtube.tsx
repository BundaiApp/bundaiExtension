import { ApolloProvider, useMutation } from "@apollo/client"
import cssText from "data-text:~style.css"
import kuromoji from "kuromoji"
import type { PlasmoCSConfig } from "plasmo"
import React, { useEffect, useRef, useState } from "react"
import { createRoot } from "react-dom/client"
import { toRomaji } from "wanakana"

import DictionaryLoadingOverlay from "../components/DictionaryLoadingOverlay"
import WordCard from "../components/WordCard"
import client from "../graphql"
import { ADD_FLASH_CARD_MUTATION } from "../graphql/mutations/addFlashCard.mutation"
import dictionaryDB from "../services/dictionaryDB"

export const getStyle = () => {
  const style = document.createElement("style")
  style.textContent = cssText
  return style
}

export const config: PlasmoCSConfig = {
  matches: ["*://www.youtube.com/watch*"],
  all_frames: false
}

export interface SubtitleCue {
  start: number
  end: number
  text: string
}

interface SubtitleSettings {
  subtitle1: {
    fontSize: number
    color: string
    backgroundColor: string
    opacity: number
  }
  subtitle2: {
    fontSize: number
    color: string
    backgroundColor: string
    opacity: number
  }
  position: number
  gap: number
}

interface WordCardStyles {
  backgroundColor?: string
  textColor?: string
  fontSize?: number
  borderRadius?: number
  borderColor?: string
  wordFontSize?: number
}

interface SubtitleContainerStyles {
  backgroundColor?: string
  textColor?: string
  fontSize?: number
  opacity?: number
  borderRadius?: number
  verticalPosition?: number
}

interface Token {
  surface_form: string
  basic_form: string
  reading: string
  pos: string
  conjugated_form: string
}

declare global {
  interface Window {
    kuromojiTokenizer: any
  }
}

let loadingOverlayContainer: HTMLDivElement | null = null
let loadingOverlayRoot: any = null

function showLoadingOverlay(progress: number, total: number) {
  if (!loadingOverlayContainer) {
    loadingOverlayContainer = document.createElement("div")
    loadingOverlayContainer.id = "bundai-loading-overlay-root"
    document.body.appendChild(loadingOverlayContainer)
    loadingOverlayRoot = createRoot(loadingOverlayContainer)
  }

  loadingOverlayRoot.render(
    <DictionaryLoadingOverlay
      progress={progress}
      total={total}
      isVisible={true}
    />
  )
}

function hideLoadingOverlay() {
  if (loadingOverlayRoot) {
    loadingOverlayRoot.render(
      <DictionaryLoadingOverlay progress={0} total={0} isVisible={false} />
    )
    setTimeout(() => {
      if (loadingOverlayRoot) {
        loadingOverlayRoot.unmount()
        loadingOverlayRoot = null
      }
      if (loadingOverlayContainer) {
        loadingOverlayContainer.remove()
        loadingOverlayContainer = null
      }
    }, 300)
  }
}

class YouTubeSubtitleContainer {
  private videoElement: HTMLVideoElement | null = null
  private subtitleContainer: HTMLDivElement | null = null
  private subtitle1Element: HTMLDivElement | null = null
  private subtitle2Element: HTMLDivElement | null = null
  private wordCardContainer: HTMLDivElement | null = null
  private wordCardRoot: any = null
  private updateInterval: NodeJS.Timeout | null = null
  private observer: MutationObserver | null = null
  private isEnabled: boolean = false
  private initializationAttempts: number = 0
  private maxInitAttempts: number = 5

  private settings: SubtitleSettings = {
    subtitle1: {
      fontSize: 24,
      color: "#ffffff",
      backgroundColor: "#000000",
      opacity: 0.8
    },
    subtitle2: {
      fontSize: 20,
      color: "#ffffff",
      backgroundColor: "#000000",
      opacity: 0.8
    },
    position: 25,
    gap: 10
  }

  private subtitle1Data: SubtitleCue[] = []
  private subtitle2Data: SubtitleCue[] = []
  private subtitle1Url: string | null = null
  private subtitle2Url: string | null = null

  private autoGeneratedSubtitles: SubtitleCue[] = []

  private lastProcessedSubtitle1Text: string = ""
  private lastProcessedSubtitle2Text: string = ""

  private wordCard: {
    word: string
    mouseX: number
    mouseY: number
    isVisible: boolean
    isSticky: boolean
    basicForm?: string
    reading?: string
    pos?: string
    conjugatedForm?: string
  } = {
    word: "",
    mouseX: 0,
    mouseY: 0,
    isVisible: false,
    isSticky: false,
    basicForm: "",
    reading: "",
    pos: "",
    conjugatedForm: ""
  }

  private isJapaneseEnabled: boolean = true
  private isInitialized: boolean = false
  private wordCardStyles: WordCardStyles = {}
  private subtitleContainerStyles: SubtitleContainerStyles = {}

  constructor() {
    this.setupMessageListener()
    this.initializeJapanese()
    this.requestInitialState()
    this.setupAutoSubtitleListener()
    setTimeout(() => {
      this.loadAllSettings()
    }, 500)

    document.addEventListener("fullscreenchange", () => {
      this.reapplySubtitleStyles()
    })
    document.addEventListener("webkitfullscreenchange", () => {
      this.reapplySubtitleStyles()
    })
  }

  private reapplySubtitleStyles(): void {
    if (this.subtitle1Element) {
      this.applySubtitleStyles(this.subtitle1Element, {
        backgroundColor:
          this.subtitleContainerStyles.backgroundColor || "#000000",
        color: this.subtitleContainerStyles.textColor || "#ffffff",
        fontSize: this.subtitleContainerStyles.fontSize || 40,
        opacity: this.subtitleContainerStyles.opacity || 0.9,
        borderRadius: this.subtitleContainerStyles.borderRadius || 8
      })
    }
    if (this.subtitle2Element) {
      this.applySubtitleStyles(this.subtitle2Element, {
        backgroundColor:
          this.subtitleContainerStyles.backgroundColor || "#000000",
        color: this.subtitleContainerStyles.textColor || "#ffffff",
        fontSize: this.subtitleContainerStyles.fontSize || 40,
        opacity: this.subtitleContainerStyles.opacity || 0.9,
        borderRadius: this.subtitleContainerStyles.borderRadius || 8
      })
    }

    if (this.subtitleContainer) {
      const verticalPos =
        this.subtitleContainerStyles.verticalPosition ?? this.settings.position
      this.subtitleContainer.style.left = "50%"
      this.subtitleContainer.style.transform = "translateX(-50%)"
      this.subtitleContainer.style.bottom = `${verticalPos}%`
      this.subtitleContainer.style.top = "auto"
    }
  }

  private async loadWordCardStyles(): Promise<void> {
    try {
      const response = await new Promise<any>((resolve, reject) => {
        chrome.runtime.sendMessage(
          { action: "getWordCardStyles" },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError)
            } else {
              resolve(response)
            }
          }
        )
      })

      if (response && response.styles) {
        this.wordCardStyles = response.styles
        console.log(
          "[YouTube Subtitles] Loaded WordCard styles:",
          this.wordCardStyles
        )
        this.renderWordCard()
      }
    } catch (error) {
      console.error(
        "[YouTube Subtitles] Failed to load WordCard styles:",
        error
      )
    }
  }

  private async loadSubtitleContainerStyles(): Promise<void> {
    try {
      const response = await new Promise<any>((resolve, reject) => {
        chrome.runtime.sendMessage(
          { action: "getSubtitleContainerStyles" },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError)
            } else {
              resolve(response)
            }
          }
        )
      })

      if (response && response.styles) {
        this.subtitleContainerStyles = response.styles
        console.log(
          "[YouTube Subtitles] Loaded subtitle container styles:",
          this.subtitleContainerStyles
        )

        if (this.subtitle1Element) {
          this.applySubtitleStyles(this.subtitle1Element, {
            backgroundColor:
              this.subtitleContainerStyles.backgroundColor || "#000000",
            color: this.subtitleContainerStyles.textColor || "#ffffff",
            fontSize: this.subtitleContainerStyles.fontSize || 40,
            opacity: this.subtitleContainerStyles.opacity || 0.9,
            borderRadius: this.subtitleContainerStyles.borderRadius || 8
          })
        }
        if (this.subtitle2Element) {
          this.applySubtitleStyles(this.subtitle2Element, {
            backgroundColor:
              this.subtitleContainerStyles.backgroundColor || "#000000",
            color: this.subtitleContainerStyles.textColor || "#ffffff",
            fontSize: this.subtitleContainerStyles.fontSize || 40,
            opacity: this.subtitleContainerStyles.opacity || 0.9,
            borderRadius: this.subtitleContainerStyles.borderRadius || 8
          })
        }

        if (this.subtitleContainer) {
          const verticalPos =
            this.subtitleContainerStyles.verticalPosition ??
            this.settings.position
          this.subtitleContainer.style.left = "50%"
          this.subtitleContainer.style.transform = "translateX(-50%)"
          this.subtitleContainer.style.bottom = `${verticalPos}%`
          this.subtitleContainer.style.top = "auto"
        }
      }
    } catch (error) {
      console.error(
        "[YouTube Subtitles] Failed to load subtitle container styles:",
        error
      )
    }
  }

  private async loadAllSettings(): Promise<void> {
    await Promise.all([
      this.loadWordCardStyles(),
      this.loadSubtitleContainerStyles()
    ])
  }

  private async requestInitialState(): Promise<void> {
    console.log(
      "[YouTube Subtitles] Requesting initial state from background..."
    )

    if (document.readyState !== "complete") {
      await new Promise((resolve) => {
        window.addEventListener("load", resolve, { once: true })
      })
      await new Promise((resolve) => setTimeout(resolve, 1500))
    } else {
      await new Promise((resolve) => setTimeout(resolve, 100))
    }

    await this.requestStateWithRetry()
  }

  private async requestStateWithRetry(attempt: number = 0): Promise<void> {
    try {
      const result = await this.getExtensionEnabledState()

      this.isEnabled =
        result.extensionEnabled && !result.useAutoGeneratedSubtitles

      console.log("[YouTube Subtitles] State received:", {
        extensionEnabled: result.extensionEnabled,
        useAutoGeneratedSubtitles: result.useAutoGeneratedSubtitles,
        finalEnabled: this.isEnabled
      })

      if (this.isEnabled) {
        console.log(
          "[YouTube Subtitles] Custom subtitle mode enabled, initializing"
        )
        this.init()
      } else {
        console.log("[YouTube Subtitles] Custom subtitle mode disabled")
      }
    } catch (error) {
      console.error(
        `[YouTube Subtitles] Error getting state (attempt ${attempt + 1}/${this.maxInitAttempts}):`,
        error
      )

      if (attempt < this.maxInitAttempts - 1) {
        const delay = 500 * Math.pow(2, attempt)
        console.log(`[YouTube Subtitles] Retrying in ${delay}ms...`)
        await new Promise((resolve) => setTimeout(resolve, delay))
        return this.requestStateWithRetry(attempt + 1)
      } else {
        console.error(
          "[YouTube Subtitles] Failed to get state after all retries, assuming disabled"
        )
        this.isEnabled = false
      }
    }
  }

  private async getExtensionEnabledState(): Promise<{
    extensionEnabled: boolean
    useAutoGeneratedSubtitles: boolean
  }> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== "undefined" && chrome.runtime) {
        chrome.runtime.sendMessage(
          { action: "getExtensionState" },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError)
            } else if (!response) {
              reject(new Error("No response from background script"))
            } else {
              chrome.runtime.sendMessage(
                { action: "getUseAutoGeneratedSubtitles" },
                (subResponse) => {
                  if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError)
                  } else {
                    resolve({
                      extensionEnabled: response.enabled !== false,
                      useAutoGeneratedSubtitles:
                        subResponse?.useAutoGenerated || false
                    })
                  }
                }
              )
            }
          }
        )
      } else {
        reject(new Error("Chrome runtime not available"))
      }
    })
  }

  private async initializeJapanese(): Promise<void> {
    try {
      if (!window.kuromojiTokenizer) {
        const tokenizer = await new Promise<any>((resolve, reject) => {
          kuromoji
            .builder({
              dicPath: chrome.runtime.getURL("node_modules/kuromoji/dict/")
            })
            .build((err, tokenizer) => {
              if (err) {
                reject(err)
                return
              }
              resolve(tokenizer)
            })
        })
        window.kuromojiTokenizer = tokenizer
        console.log("[YouTube Subtitles] Kuromoji tokenizer loaded")
      }

      dictionaryDB.onProgress((progress, total) => {
        showLoadingOverlay(progress, total)
      })

      await dictionaryDB.initialize()
      console.log("[YouTube Subtitles] Dictionary database ready")

      hideLoadingOverlay()

      this.isInitialized = true
    } catch (error) {
      console.error(
        "[YouTube Subtitles] Failed to initialize Japanese processing:",
        error
      )
      hideLoadingOverlay()
      this.isInitialized = false
    }
  }

  private init(): void {
    if (!this.isEnabled) {
      console.log(
        "[YouTube Subtitles] Extension disabled, skipping initialization"
      )
      return
    }

    this.findAndSetupVideo()
    if (!this.videoElement) {
      this.observeForVideo()
    }
  }

  private findAndSetupVideo(): void {
    if (!this.isEnabled) return

    const videos = document.querySelectorAll(
      "video"
    ) as NodeListOf<HTMLVideoElement>

    if (videos.length > 0) {
      let targetVideo = Array.from(videos).find(
        (video) =>
          video.classList.contains("html5-main-video") ||
          video.closest(".html5-video-player")
      )

      if (!targetVideo) {
        targetVideo = Array.from(videos).reduce((largest, current) => {
          const largestArea = largest.offsetWidth * largest.offsetHeight
          const currentArea = current.offsetWidth * current.offsetHeight
          return currentArea > largestArea ? current : largest
        })
      }

      if (targetVideo && targetVideo !== this.videoElement) {
        this.videoElement = targetVideo
        this.setupSubtitleContainer()
        console.log(
          "[YouTube Subtitles] Video element found and subtitles setup"
        )
      }
    }
  }

  private observeForVideo(): void {
    if (!this.isEnabled) return

    this.observer = new MutationObserver((mutations) => {
      if (this.videoElement || !this.isEnabled) return

      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          const addedNodes = Array.from(mutation.addedNodes) as Element[]
          for (const node of addedNodes) {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const videos = (node as Element).querySelectorAll?.("video") || []
              if (videos.length > 0 || (node as Element).tagName === "VIDEO") {
                this.findAndSetupVideo()
                if (this.videoElement) {
                  this.observer?.disconnect()
                  return
                }
              }
            }
          }
        }
      }
    })

    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    })
  }

  private setupSubtitleContainer(): void {
    if (!this.isEnabled) return
    if (!this.videoElement) return

    document
      .querySelectorAll(
        ".custom-subtitle-container, .react-word-card-container, #bundai-subtitle-root, #bundai-wordcard-root"
      )
      .forEach((el) => el.remove())
    this.removeSubtitleContainer()

    if (document.getElementById("bundai-subtitle-root")) {
      return
    }

    this.subtitleContainer = document.createElement("div")
    this.subtitleContainer.id = "bundai-subtitle-root"
    this.subtitleContainer.className = "custom-subtitle-container"
    this.subtitleContainer.style.cssText = `
      position: fixed;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: ${this.settings.gap}px;
      pointer-events: auto;
      max-width: 80%;
      min-width: 300px;
    `

    this.subtitle1Element = document.createElement("div")
    this.subtitle1Element.className = "custom-subtitle subtitle-1"
    this.subtitle1Element.style.cursor = "default"
    this.applySubtitleStyles(this.subtitle1Element, this.settings.subtitle1)
    this.subtitleContainer.appendChild(this.subtitle1Element)

    this.subtitle2Element = document.createElement("div")
    this.subtitle2Element.className = "custom-subtitle subtitle-2"
    this.subtitle2Element.style.cursor = "default"
    this.applySubtitleStyles(this.subtitle2Element, this.settings.subtitle2)
    this.subtitleContainer.appendChild(this.subtitle2Element)

    this.createReactWordCard()

    document.body.appendChild(this.subtitleContainer)

    this.loadSavedPosition()
    this.startSubtitleUpdates()

    console.log("[YouTube Subtitles] Subtitle container created and positioned")

    this.loadSavedSubtitles()
  }

  private loadSavedPosition(): void {
    if (!this.subtitleContainer) return

    const verticalPos =
      this.subtitleContainerStyles.verticalPosition ?? this.settings.position
    this.subtitleContainer.style.left = "50%"
    this.subtitleContainer.style.transform = "translateX(-50%)"
    this.subtitleContainer.style.bottom = `${verticalPos}%`
    this.subtitleContainer.style.top = "auto"
  }

  public setEnabled(enabled: boolean): void {
    const wasEnabled = this.isEnabled
    this.isEnabled = enabled

    console.log(
      `[YouTube Subtitles] Extension ${enabled ? "enabled" : "disabled"}`
    )

    if (enabled && !wasEnabled) {
      this.init()
    } else if (!enabled && wasEnabled) {
      this.removeSubtitleContainer()
      this.observer?.disconnect()
      this.observer = null
      this.videoElement = null

      this.lastProcessedSubtitle1Text = ""
      this.lastProcessedSubtitle2Text = ""

      this.wordCard = {
        word: "",
        mouseX: 0,
        mouseY: 0,
        isVisible: false,
        isSticky: false
      }
    }
  }

  private createReactWordCard(): void {
    if (document.getElementById("bundai-wordcard-root")) {
      document.getElementById("bundai-wordcard-root")?.remove()
    }
    this.wordCardContainer = document.createElement("div")
    this.wordCardContainer.id = "bundai-wordcard-root"
    this.wordCardContainer.className = "react-word-card-container"
    this.wordCardContainer.style.position = "fixed"
    this.wordCardContainer.style.zIndex = "2147483647"

    document.body.appendChild(this.wordCardContainer)

    this.wordCardRoot = createRoot(this.wordCardContainer)
    this.renderWordCard()
  }

  private renderWordCard(): void {
    if (!this.wordCardRoot || !this.wordCardContainer) return

    const containerRect =
      this.subtitleContainer?.getBoundingClientRect() || null

    this.wordCardRoot.render(
      <WordCardManager
        wordCard={this.wordCard}
        containerRect={containerRect}
        onClose={this.handleCardClose.bind(this)}
        customStyles={this.wordCardStyles}
      />
    )
  }

  private handleCardClose(): void {
    this.wordCard = {
      ...this.wordCard,
      isVisible: false,
      isSticky: false,
      word: ""
    }
    this.renderWordCard()
  }

  private applySubtitleStyles(
    element: HTMLDivElement,
    subtitleSettings: any
  ): void {
    const borderRadius = subtitleSettings.borderRadius ?? 8
    const opacity = subtitleSettings.opacity ?? 0.9

    element.style.cssText = `
      background: ${this.hexToRgba(subtitleSettings.backgroundColor, opacity)};
      color: ${subtitleSettings.color};
      font-size: ${subtitleSettings.fontSize}px;
      font-family: Arial, sans-serif;
      font-weight: bold;
      padding: 8px 16px;
      border-radius: ${borderRadius}px;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      line-height: 1.4;
      min-height: 20px;
      display: none;
      word-wrap: break-word;
      white-space: pre-wrap;
      max-width: 100%;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      cursor: default;
    `
  }

  private hexToRgba(hex: string, opacity: number): string {
    const r = parseInt(hex.slice(1, 3), 16)
    const g = parseInt(hex.slice(3, 5), 16)
    const b = parseInt(hex.slice(5, 7), 16)
    return `rgba(${r}, ${g}, ${b}, ${opacity})`
  }

  private startSubtitleUpdates(): void {
    if (!this.isEnabled) return

    if (this.updateInterval) {
      clearInterval(this.updateInterval)
    }

    this.updateInterval = setInterval(() => {
      this.updateSubtitles()
    }, 100)
  }

  private updateSubtitles(): void {
    if (!this.subtitle1Element || !this.subtitle2Element || !this.isEnabled)
      return

    if (!this.videoElement) return

    const currentTime = this.videoElement.currentTime

    const subtitle1Cue = this.subtitle1Data.find(
      (cue) => currentTime >= cue.start && currentTime <= cue.end
    )

    if (subtitle1Cue) {
      this.subtitle1Element.style.display = "block"
      if (subtitle1Cue.text !== this.lastProcessedSubtitle1Text) {
        this.lastProcessedSubtitle1Text = subtitle1Cue.text
        this.processSubtitleElement(this.subtitle1Element, subtitle1Cue.text)
      }
    } else {
      this.subtitle1Element.style.display = "none"
      if (this.lastProcessedSubtitle1Text !== "") {
        this.lastProcessedSubtitle1Text = ""
        this.subtitle1Element.textContent = ""
      }
    }

    const subtitle2Cue = this.subtitle2Data.find(
      (cue) => currentTime >= cue.start && currentTime <= cue.end
    )

    if (subtitle2Cue) {
      this.subtitle2Element.style.display = "block"
      if (subtitle2Cue.text !== this.lastProcessedSubtitle2Text) {
        this.lastProcessedSubtitle2Text = subtitle2Cue.text
        this.processSubtitleElement(this.subtitle2Element, subtitle2Cue.text)
      }
    } else {
      this.subtitle2Element.style.display = "none"
      if (this.lastProcessedSubtitle2Text !== "") {
        this.lastProcessedSubtitle2Text = ""
        this.subtitle2Element.textContent = ""
      }
    }
  }

  private hoverTimeout: NodeJS.Timeout | null = null

  private processSubtitleElement(element: HTMLDivElement, text: string): void {
    if (
      !this.isJapaneseEnabled ||
      !this.isInitialized ||
      !this.isJapaneseText(text)
    ) {
      element.textContent = text
      return
    }

    const tokens = this.tokenizeJapanese(text)
    if (tokens.length === 0) {
      element.textContent = text
      return
    }

    const tempContainer = document.createElement("div")
    tempContainer.style.display = "contents"

    let globalCharIndex = 0

    tempContainer.innerHTML = tokens
      .map((token, tokenIndex) => {
        const chars = token.surface_form
          .split("")
          .map((char, charIndex) => {
            const span = `<span class="char-span" 
                   data-char="${this.escapeHtml(char)}" 
                   data-char-index="${globalCharIndex + charIndex}" 
                   data-token-id="${tokenIndex}" 
                   data-token-word="${this.escapeHtml(token.surface_form)}" 
                   data-basic-form="${this.escapeHtml(token.basic_form)}" 
                   data-reading="${this.escapeHtml(token.reading)}" 
                   data-pos="${this.escapeHtml(token.pos)}">${this.escapeHtml(char)}</span>`
            return span
          })
          .join("")
        globalCharIndex += token.surface_form.length
        return chars
      })
      .join("")

    const charSpans = tempContainer.querySelectorAll(".char-span")
    charSpans.forEach((spanElement) => {
      const charIndex = parseInt(
        spanElement.getAttribute("data-char-index") || "0"
      )

      spanElement.addEventListener("mouseenter", (e) => {
        if (this.hoverTimeout) clearTimeout(this.hoverTimeout)
        this.hoverTimeout = setTimeout(() => {
          this.handleCharacterHover(charIndex, (e as MouseEvent).clientX)
        }, 20)
      })

      spanElement.addEventListener("mouseleave", () => {
        if (this.hoverTimeout) clearTimeout(this.hoverTimeout)
      })

      spanElement.addEventListener("click", (e) => {
        e.stopPropagation()
        this.findBestMatch(charIndex).then((match) => {
          if (match) {
            const startChar = document.querySelector(
              `[data-char-index="${match.startIndex}"]`
            ) as HTMLElement
            const rect = startChar.getBoundingClientRect()
            this.handleWordClickWithMetadata(
              match.matchedText,
              rect.left + rect.width / 2,
              rect.top,
              {
                basicForm: match.entry.basic_form || match.matchedText,
                reading: match.entry.reading || "",
                pos: match.entry.pos || "",
                conjugatedForm: ""
              }
            )
          }
        })
      })
    })

    element.innerHTML = ""
    element.appendChild(tempContainer)

    element.addEventListener(
      "mouseenter",
      this.handleSubtitleMouseEnter.bind(this)
    )
    element.addEventListener("mouseleave", this.handleSubtitleLeave.bind(this))
  }

  private handleSubtitleMouseEnter(): void {
    if (this.videoElement && typeof this.videoElement.pause === "function") {
      this.videoElement.pause()
    }
  }

  private handleSubtitleLeave(): void {
    if (this.videoElement && typeof this.videoElement.play === "function") {
      this.videoElement.play()
    }
    this.clearHighlights()
  }

  private async handleCharacterHover(
    charIndex: number,
    mouseX: number
  ): Promise<void> {
    const bestMatch = await this.findBestMatch(charIndex)

    if (bestMatch) {
      this.highlightRegion(bestMatch.startIndex, bestMatch.length)

      const startChar = document.querySelector(
        `[data-char-index="${bestMatch.startIndex}"]`
      ) as HTMLElement
      const rect = startChar.getBoundingClientRect()

      this.wordCard = {
        word: bestMatch.matchedText,
        mouseX: rect.left + rect.width / 2,
        mouseY: rect.top,
        isVisible: true,
        isSticky: false,
        basicForm: bestMatch.entry.basic_form || bestMatch.matchedText,
        reading: bestMatch.entry.reading || "",
        pos: bestMatch.entry.pos || "",
        conjugatedForm: ""
      }
      this.renderWordCard()
    } else {
      this.clearHighlights()
      if (!this.wordCard.isSticky) {
        this.wordCard.isVisible = false
        this.renderWordCard()
      }
    }
  }

  private async findBestMatch(
    startIndex: number,
    maxLength: number = 10
  ): Promise<{
    startIndex: number
    length: number
    matchedText: string
    entry: any
  } | null> {
    let chars = ""
    let matchedEntry: any = null
    let matchedLength = 0
    const currentTokenId = document
      .querySelector(`[data-char-index="${startIndex}"]`)
      ?.getAttribute("data-token-id")

    for (let i = 0; i < maxLength; i++) {
      const targetIndex = startIndex + i
      const span = document.querySelector(
        `[data-char-index="${targetIndex}"]`
      ) as HTMLElement

      if (!span) break

      const tokenId = span.getAttribute("data-token-id")

      if (i > 0 && tokenId !== currentTokenId) {
        break
      }

      chars += span.getAttribute("data-char") || ""

      try {
        const entry = await dictionaryDB.lookup(chars)
        if (entry) {
          matchedEntry = entry
          matchedLength = i + 1
        }
      } catch (error) {
        console.error("[YouTube Subtitles] Lookup error:", error)
      }
    }

    if (matchedLength > 0) {
      return {
        startIndex,
        length: matchedLength,
        matchedText: chars.substring(0, matchedLength),
        entry: matchedEntry
      }
    }

    return null
  }

  private highlightRegion(startIndex: number, length: number): void {
    this.clearHighlights()

    for (let i = 0; i < length; i++) {
      const index = startIndex + i
      const span = document.querySelector(
        `[data-char-index="${index}"]`
      ) as HTMLElement
      if (span) {
        span.classList.add("matched-region")
      }
    }
  }

  private clearHighlights(): void {
    document.querySelectorAll(".matched-region").forEach((el) => {
      el.classList.remove("matched-region")
    })
  }

  private escapeHtml(text: string): string {
    const div = document.createElement("div")
    div.textContent = text
    return div.innerHTML
  }

  private handleWordClick(word: string, mouseX: number, mouseY: number): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: true
    }
    this.renderWordCard()
  }

  private handleWordHoverWithMetadata(
    word: string,
    mouseX: number,
    mouseY: number,
    metadata: {
      basicForm: string
      reading: string
      pos: string
      conjugatedForm: string
    }
  ): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: false,
      basicForm: metadata.basicForm,
      reading: metadata.reading,
      pos: metadata.pos,
      conjugatedForm: metadata.conjugatedForm
    }
    this.renderWordCard()
  }

  private handleWordClickWithMetadata(
    word: string,
    mouseX: number,
    mouseY: number,
    metadata: {
      basicForm: string
      reading: string
      pos: string
      conjugatedForm: string
    }
  ): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: true,
      basicForm: metadata.basicForm,
      reading: metadata.reading,
      pos: metadata.pos,
      conjugatedForm: metadata.conjugatedForm
    }
    this.renderWordCard()
  }

  private isJapaneseText(text: string): boolean {
    return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text)
  }

  private tokenizeJapanese(text: string): Token[] {
    if (!window.kuromojiTokenizer) return []
    return window.kuromojiTokenizer.tokenize(text)
  }

  private removeSubtitleContainer(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval)
      this.updateInterval = null
    }

    if (this.subtitleContainer) {
      this.subtitleContainer.remove()
      this.subtitleContainer = null
      this.subtitle1Element = null
      this.subtitle2Element = null
    }

    if (this.wordCardRoot) {
      this.wordCardRoot.unmount()
      this.wordCardRoot = null
    }

    if (this.wordCardContainer) {
      this.wordCardContainer.remove()
      this.wordCardContainer = null
    }

    this.lastProcessedSubtitle1Text = ""
    this.lastProcessedSubtitle2Text = ""

    this.wordCard = {
      word: "",
      mouseX: 0,
      mouseY: 0,
      isVisible: false,
      isSticky: false
    }
  }

  public updateSettings(newSettings: Partial<SubtitleSettings>): void {
    this.settings = { ...this.settings, ...newSettings }

    if (this.subtitleContainer && this.isEnabled) {
      const verticalPos =
        this.subtitleContainerStyles.verticalPosition ?? this.settings.position
      this.subtitleContainer.style.bottom = `${verticalPos}%`
      this.subtitleContainer.style.gap = `${this.settings.gap}px`
    }

    if (this.subtitle1Element && this.isEnabled) {
      this.applySubtitleStyles(this.subtitle1Element, this.settings.subtitle1)
    }

    if (this.subtitle2Element && this.isEnabled) {
      this.applySubtitleStyles(this.subtitle2Element, this.settings.subtitle2)
    }
  }

  public updateSubtitleData(
    subtitle1Data?: SubtitleCue[],
    subtitle2Data?: SubtitleCue[]
  ): void {
    if (subtitle1Data) {
      this.subtitle1Data = subtitle1Data
      this.lastProcessedSubtitle1Text = ""
    }
    if (subtitle2Data) {
      this.subtitle2Data = subtitle2Data
      this.lastProcessedSubtitle2Text = ""
    }
  }

  public async loadSubtitleFromUrl(
    urlOrContent: string,
    trackNumber: 1 | 2
  ): Promise<void> {
    if (!this.isEnabled) {
      console.log(
        "[YouTube Subtitles] Extension disabled, not loading subtitles"
      )
      return
    }

    try {
      console.log(
        `[YouTube Subtitles] loadSubtitleFromUrl called: track=${trackNumber}, value length=${urlOrContent.length}`
      )

      const isVttContent =
        urlOrContent.startsWith("WEBVTT") || urlOrContent.includes("\n")

      if (trackNumber === 1) {
        this.subtitle1Url = isVttContent ? "vtt-content" : urlOrContent
      } else {
        this.subtitle2Url = isVttContent ? "vtt-content" : urlOrContent
      }

      let subtitleText: string

      if (isVttContent) {
        subtitleText = urlOrContent
      } else {
        const response = await fetch(urlOrContent)
        subtitleText = await response.text()
      }

      const parsedSubtitles = this.parseSubtitleText(subtitleText)

      if (trackNumber === 1) {
        this.subtitle1Data = parsedSubtitles
        this.lastProcessedSubtitle1Text = ""
      } else {
        this.subtitle2Data = parsedSubtitles
        this.lastProcessedSubtitle2Text = ""
      }
    } catch (error) {
      console.error(
        `[YouTube Subtitles] Error loading subtitle ${trackNumber}:`,
        error
      )
    }
  }

  private parseSubtitleText(subtitleText: string): SubtitleCue[] {
    const cues: SubtitleCue[] = []

    if (subtitleText.includes("WEBVTT")) {
      return this.parseVTT(subtitleText)
    } else if (subtitleText.match(/^\d+\s*$/m)) {
      return this.parseSRT(subtitleText)
    }

    return cues
  }

  private parseVTT(vttText: string): SubtitleCue[] {
    const cues: SubtitleCue[] = []
    const lines = vttText.split("\n")

    let i = 0
    while (i < lines.length) {
      const line = lines[i].trim()

      if (line.includes("-->")) {
        const timeMatch = line.match(
          /(\d{2}:)?(\d{2}):(\d{2})\.(\d{3})\s*-->\s*(\d{2}:)?(\d{2}):(\d{2})\.(\d{3})/
        )

        if (timeMatch) {
          const startTime = this.parseTimeToSeconds(
            timeMatch[0].split("-->")[0].trim()
          )
          const endTime = this.parseTimeToSeconds(
            timeMatch[0].split("-->")[1].trim()
          )

          i++
          let text = ""
          while (i < lines.length && lines[i].trim() !== "") {
            if (text) text += " "
            text += lines[i].trim()
            i++
          }

          if (text) {
            cues.push({
              start: startTime,
              end: endTime,
              text: text.replace(/<[^>]*>/g, "")
            })
          }
        }
      }
      i++
    }

    return cues
  }

  private parseSRT(srtText: string): SubtitleCue[] {
    const cues: SubtitleCue[] = []
    const blocks = srtText.split(/\n\s*\n/)

    for (const block of blocks) {
      const lines = block.trim().split("\n")
      if (lines.length >= 3) {
        const timeMatch = lines[1].match(
          /(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/
        )

        if (timeMatch) {
          const startTime = this.parseTimeToSeconds(
            lines[1].split("-->")[0].trim().replace(",", ".")
          )
          const endTime = this.parseTimeToSeconds(
            lines[1].split("-->")[1].trim().replace(",", ".")
          )

          const text = lines
            .slice(2)
            .join(" ")
            .replace(/<[^>]*>/g, "")

          cues.push({
            start: startTime,
            end: endTime,
            text: text
          })
        }
      }
    }

    return cues
  }

  private parseTimeToSeconds(timeStr: string): number {
    const parts = timeStr.match(/(?:(\d{2}):)?(\d{2}):(\d{2})[\.,](\d{3})/)
    if (!parts) return 0

    const hours = parseInt(parts[1] || "0")
    const minutes = parseInt(parts[2])
    const seconds = parseInt(parts[3])
    const milliseconds = parseInt(parts[4])

    return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000
  }

  private setupMessageListener(): void {
    if (typeof chrome !== "undefined" && chrome.runtime) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (message.action === "loadSubtitle") {
          this.loadSubtitleFromUrl(message.url, message.trackNumber)
            .then(() => sendResponse({ success: true }))
            .catch((error) =>
              sendResponse({ success: false, error: error.message })
            )
          return true
        }

        if (message.action === "updateSettings") {
          this.updateSettings(message.settings)
          sendResponse({ success: true })
        }

        if (message.action === "setJapaneseEnabled") {
          this.isJapaneseEnabled = message.enabled
          sendResponse({ success: true })
        }

        if (message.action === "setExtensionEnabled") {
          console.log(
            "[YouTube Subtitles] Received setExtensionEnabled:",
            message.enabled
          )
          this.setEnabled(message.enabled)
          sendResponse({ success: true })
          return true
        }

        if (message.action === "getExtensionState") {
          sendResponse({ enabled: this.isEnabled })
          return true
        }

        if (message.action === "checkStatus") {
          console.log("[YouTube Subtitles] Status check requested")
          const hasContainer = !!document.getElementById("bundai-subtitle-root")
          sendResponse({
            isEnabled: this.isEnabled,
            hasContainer: hasContainer,
            videoElement: !!this.videoElement
          })
          return true
        }

        if (message.action === "setWordCardStyles") {
          this.wordCardStyles = message.styles || {}
          this.renderWordCard()
          sendResponse({ success: true })
          return true
        }

        if (message.action === "setSubtitleContainerStyles") {
          this.subtitleContainerStyles = message.styles || {}

          if (this.subtitle1Element) {
            this.applySubtitleStyles(this.subtitle1Element, {
              backgroundColor:
                this.subtitleContainerStyles.backgroundColor || "#000000",
              color: this.subtitleContainerStyles.textColor || "#ffffff",
              fontSize: this.subtitleContainerStyles.fontSize || 40,
              opacity: this.subtitleContainerStyles.opacity || 0.9,
              borderRadius: this.subtitleContainerStyles.borderRadius || 8
            })
          }
          if (this.subtitle2Element) {
            this.applySubtitleStyles(this.subtitle2Element, {
              backgroundColor:
                this.subtitleContainerStyles.backgroundColor || "#000000",
              color: this.subtitleContainerStyles.textColor || "#ffffff",
              fontSize: this.subtitleContainerStyles.fontSize || 40,
              opacity: this.subtitleContainerStyles.opacity || 0.9,
              borderRadius: this.subtitleContainerStyles.borderRadius || 8
            })
          }

          if (this.subtitleContainer) {
            const verticalPos =
              this.subtitleContainerStyles.verticalPosition ??
              this.settings.position
            this.subtitleContainer.style.left = "50%"
            this.subtitleContainer.style.transform = "translateX(-50%)"
            this.subtitleContainer.style.bottom = `${verticalPos}%`
            this.subtitleContainer.style.top = "auto"
          }

          sendResponse({ success: true })
          return true
        }

        if (message.action === "setSubtitleMode") {
          const mode = message.subtitleMode as "api" | "user"
          console.log("[YouTube Subtitles] setSubtitleMode:", mode)

          if (!this.isEnabled) {
            this.setEnabled(true)
          }
          if (!this.subtitleContainer) {
            this.findAndSetupVideo()
          }

          this.subtitle1Data = []
          this.lastProcessedSubtitle1Text = ""

          if (mode === "api") {
            this.loadSavedSubtitles()
          } else if (mode === "user") {
            const videoId = this.extractVideoId(window.location.href)
            if (videoId) {
              this.loadSavedUserSubtitles(videoId)
            }
          }

          sendResponse({ success: true })
          return true
        }

        if (message.action === "loadUserSubtitle") {
          console.log("[YouTube Subtitles] loadUserSubtitle received")
          const { cues, trackNumber } = message

          if (!this.isEnabled) {
            this.setEnabled(true)
          }
          if (!this.subtitleContainer) {
            this.setupSubtitleContainer()
          }

          if (trackNumber === 1) {
            this.subtitle1Data = cues
            this.lastProcessedSubtitle1Text = ""
          } else {
            this.subtitle2Data = cues
            this.lastProcessedSubtitle2Text = ""
          }

          sendResponse({ success: true })
          return true
        }

        if (message.action === "clearUserSubtitle") {
          const { trackNumber } = message
          if (trackNumber === 1) {
            this.subtitle1Data = []
            this.lastProcessedSubtitle1Text = ""
          } else {
            this.subtitle2Data = []
            this.lastProcessedSubtitle2Text = ""
          }
          sendResponse({ success: true })
          return true
        }
      })
    }

    window.addEventListener("loadSubtitle", (event: CustomEvent) => {
      if (!this.isEnabled) return
      const { url, trackNumber } = event.detail
      this.loadSubtitleFromUrl(url, trackNumber)
    })

    window.addEventListener(
      "persistSubtitleSelection",
      (event: CustomEvent) => {
        if (!this.isEnabled) return
        const { subtitle1Url, subtitle2Url } = event.detail
        if (subtitle1Url) this.loadSubtitleFromUrl(subtitle1Url, 1)
        if (subtitle2Url) this.loadSubtitleFromUrl(subtitle2Url, 2)
      }
    )
  }

  private setupAutoSubtitleListener(): void {
    window.addEventListener("autoSubtitleExtracted", (event: CustomEvent) => {
      const { cue, language, isAutoGenerated } = event.detail

      if (isAutoGenerated) {
        this.autoGeneratedSubtitles.push(cue)

        if (this.autoGeneratedSubtitles.length > 500) {
          this.autoGeneratedSubtitles = this.autoGeneratedSubtitles.slice(-250)
        }

        console.log(
          `[YouTube Subtitles] Auto-generated subtitle: "${cue.text}"`
        )
      }
    })
  }

  public getAutoGeneratedSubtitles(): SubtitleCue[] {
    return [...this.autoGeneratedSubtitles]
  }

  public destroy(): void {
    this.observer?.disconnect()
    this.removeSubtitleContainer()
    this.videoElement = null
    this.isInitialized = false
    this.isEnabled = false
  }

  public getCurrentSubtitleUrls(): {
    subtitle1Url: string | null
    subtitle2Url: string | null
  } {
    return {
      subtitle1Url: this.subtitle1Url,
      subtitle2Url: this.subtitle2Url
    }
  }

  public async loadSavedSubtitles(): Promise<void> {
    if (!this.isEnabled) {
      console.log(
        "[YouTube Subtitles] loadSavedSubtitles: Not enabled, skipping"
      )
      return
    }

    try {
      const videoId = this.extractVideoId(window.location.href)
      if (!videoId) {
        console.log("[YouTube Subtitles] loadSavedSubtitles: No video ID found")
        return
      }

      const result = await chrome.storage.local.get([
        `subtitle1_${videoId}`,
        `subtitle2_${videoId}`
      ])

      const subtitle1Url = result[`subtitle1_${videoId}`]
      const subtitle2Url = result[`subtitle2_${videoId}`]

      console.log("[YouTube Subtitles] Saved subtitle URLs:", {
        subtitle1Url,
        subtitle2Url
      })

      if (subtitle1Url || subtitle2Url) {
        if (subtitle1Url) {
          await this.loadSubtitleFromUrl(subtitle1Url, 1)
          console.log("[YouTube Subtitles] Auto-loaded subtitle 1")
        }
        if (subtitle2Url) {
          await this.loadSubtitleFromUrl(subtitle2Url, 2)
          console.log("[YouTube Subtitles] Auto-loaded subtitle 2")
        }
      } else {
        console.log(
          "[YouTube Subtitles] No saved subtitles found for this video"
        )
      }
    } catch (error) {
      console.error(
        "[YouTube Subtitles] Failed to load saved subtitles:",
        error
      )
    }
  }

  private async loadSavedUserSubtitles(videoId: string): Promise<void> {
    try {
      const result = await chrome.storage.local.get([`userSubtitle_${videoId}`])
      const saved = result[`userSubtitle_${videoId}`]

      if (saved?.cues) {
        const offset = saved.timeOffset || 0
        const adjustedCues = saved.cues.map((cue: SubtitleCue) => ({
          ...cue,
          start: Math.max(0, cue.start + offset),
          end: Math.max(0, cue.end + offset)
        }))

        this.subtitle1Data = adjustedCues
        this.lastProcessedSubtitle1Text = ""
        console.log(
          `[YouTube Subtitles] Loaded user subtitle: ${saved.fileName} (${adjustedCues.length} cues)`
        )
      } else {
        console.log("[YouTube Subtitles] No user subtitle found for this video")
      }
    } catch (error) {
      console.error("[YouTube Subtitles] Failed to load user subtitle:", error)
    }
  }

  private extractVideoId(url: string): string | null {
    if (!url) return null

    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&?/]+)/i,
      /youtube\.com\/watch.*?[?&]v=([^&?/]+)/i
    ]

    for (const pattern of patterns) {
      const match = url.match(pattern)
      if (match && match[1]) {
        return match[1]
      }
    }

    return null
  }
}

const WordCardManager: React.FC<{
  wordCard: {
    word: string
    mouseX: number
    mouseY: number
    isVisible: boolean
    isSticky: boolean
    basicForm?: string
    reading?: string
    pos?: string
    conjugatedForm?: string
  }
  containerRect: DOMRect | null
  onClose: () => void
  customStyles?: WordCardStyles
}> = ({ wordCard, containerRect, onClose, customStyles }) => {
  return (
    <WordCard
      word={wordCard.word}
      mouseX={wordCard.mouseX}
      mouseY={wordCard.mouseY}
      isVisible={wordCard.isVisible}
      isSticky={wordCard.isSticky}
      onClose={onClose}
      containerRect={containerRect}
      customStyles={customStyles}
      basicForm={wordCard.basicForm}
      reading={wordCard.reading}
      pos={wordCard.pos}
      conjugatedForm={wordCard.conjugatedForm}
    />
  )
}

let subtitleContainer: YouTubeSubtitleContainer | null = null
let initialEnabled: boolean | null = null

if (window.top === window.self) {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeSubtitles)
  } else {
    initializeSubtitles()
  }
}

async function initializeSubtitles() {
  if ((window as any).__bundaiSubtitleInit) {
    return
  }
  ;(window as any).__bundaiSubtitleInit = true

  if (subtitleContainer) {
    subtitleContainer.destroy()
  }

  subtitleContainer = new YouTubeSubtitleContainer()

  if (initialEnabled === null) {
    initialEnabled = (subtitleContainer as any).isEnabled
  }

  console.log("[YouTube Subtitles] Subtitle system initialized")
}

if (typeof chrome !== "undefined" && chrome.runtime) {
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === "setExtensionEnabled") {
      const newEnabled = message.enabled
      const wasEnabled = (subtitleContainer as any)?.isEnabled

      if (subtitleContainer) {
        subtitleContainer.setEnabled(newEnabled)
      }

      sendResponse({ success: true })
      return true
    }

    if (message.action === "setWordCardStyles") {
      if (subtitleContainer) {
        ;(subtitleContainer as any).wordCardStyles = message.styles || {}
        if (typeof (subtitleContainer as any).renderWordCard === "function") {
          ;(subtitleContainer as any).renderWordCard()
        }
      }
      sendResponse({ success: true })
      return true
    }

    if (message.action === "setSubtitleContainerStyles") {
      if (subtitleContainer) {
        ;(subtitleContainer as any).subtitleContainerStyles =
          message.styles || {}
        if (
          typeof (subtitleContainer as any).reapplySubtitleStyles === "function"
        ) {
          ;(subtitleContainer as any).reapplySubtitleStyles()
        }
      }
      sendResponse({ success: true })
      return true
    }

    if (message.action === "getExtensionState") {
      if (subtitleContainer) {
        sendResponse({ enabled: (subtitleContainer as any).isEnabled })
      } else {
        sendResponse({ enabled: false })
      }
      return true
    }

    if (message.action === "checkStatus") {
      const hasContainer = !!document.getElementById("bundai-subtitle-root")
      sendResponse({
        isEnabled: (subtitleContainer as any)?.isEnabled || false,
        hasContainer: hasContainer,
        videoElement: !!(subtitleContainer as any)?.videoElement
      })
      return true
    }

    if (message.action === "getUseAutoGeneratedSubtitles") {
      sendResponse({ useAutoGenerated: false })
      return true
    }

    if (message.action === "updateAllTabs") {
      if (subtitleContainer) {
        const newEnabled = message.enabled
        ;(subtitleContainer as any).isEnabled = newEnabled
        if (newEnabled) {
          ;(subtitleContainer as any).init()
        } else {
          ;(subtitleContainer as any).removeSubtitleContainer()
        }
      }
      sendResponse({ success: true })
      return true
    }
  })
}
