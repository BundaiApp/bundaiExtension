import cssText from "data-text:~style.css"
import type { PlasmoCSConfig } from "plasmo"
import kuromoji from "kuromoji"
import { createRoot } from "react-dom/client"
import React from "react"
import WordCard from "~components/WordCard"
import DictionaryLoadingOverlay from "~components/DictionaryLoadingOverlay"
import dictionaryDB from "~services/dictionaryDB"

export const getStyle = () => {
  const style = document.createElement("style")
  style.textContent = cssText
  return style
}

export const config: PlasmoCSConfig = {
  matches: ["*://*.youtube.com/watch*"],
  all_frames: false
}

interface Token {
  surface_form: string
}

declare global {
  interface Window {
    kuromojiTokenizer: any
    __bundaiHoverListenersAttached?: boolean
    __bundaiLoadingOverlayRoot?: any
  }
}

// Global loading overlay manager
let loadingOverlayContainer: HTMLDivElement | null = null
let loadingOverlayRoot: any = null

function showLoadingOverlay(progress: number, total: number) {
  if (!loadingOverlayContainer) {
    loadingOverlayContainer = document.createElement("div")
    loadingOverlayContainer.id = "bundai-loading-overlay-root"
    document.body.appendChild(loadingOverlayContainer)
    loadingOverlayRoot = createRoot(loadingOverlayContainer)
  }
  
  loadingOverlayRoot.render(
    <DictionaryLoadingOverlay progress={progress} total={total} isVisible={true} />
  )
}

function hideLoadingOverlay() {
  if (loadingOverlayRoot) {
    loadingOverlayRoot.render(
      <DictionaryLoadingOverlay progress={0} total={0} isVisible={false} />
    )
    setTimeout(() => {
      if (loadingOverlayRoot) {
        loadingOverlayRoot.unmount()
        loadingOverlayRoot = null
      }
      if (loadingOverlayContainer) {
        loadingOverlayContainer.remove()
        loadingOverlayContainer = null
      }
    }, 300)
  }
}

interface WordCardStyles {
  backgroundColor?: string
  textColor?: string
  fontSize?: number
  borderRadius?: number
  borderColor?: string
  wordFontSize?: number
}

class YouTubeSubtitleManipulator {
  public isEnabled: boolean = false
  private isInitialized: boolean = false
  private lastCaptionText: string = ""
  private updateInterval: NodeJS.Timeout | null = null
  private observer: MutationObserver | null = null
  private captionObserver: MutationObserver | null = null // ✅ New observer for caption changes
  private wordCardContainer: HTMLDivElement | null = null
  private wordCardRoot: any = null
  private initializationAttempts: number = 0
  private maxInitAttempts: number = 5
  private wordCardStyles: WordCardStyles = {}

  private wordCard: {
    word: string
    mouseX: number
    mouseY: number
    isVisible: boolean
    isSticky: boolean
  } = {
    word: "",
    mouseX: 0,
    mouseY: 0,
    isVisible: false,
    isSticky: false
  }

  constructor() {
    // Start dict loading immediately in background
    this.initializeJapanese()
    
    // Start monitoring immediately - will activate when enabled AND dict ready
    this.startPersistentMonitoring()
    
    // Load initial state asynchronously (non-blocking)
    this.loadInitialState()
    // Delay style loading to ensure background is ready
    setTimeout(() => this.loadWordCardStyles(), 500)
  }

  private async loadInitialState(): Promise<void> {
    try {
      const result = await this.getUseAutoGeneratedSubtitles()
      
      this.isEnabled = result.useAutoGenerated && result.extensionEnabled
      
      console.log("[YouTube Manipulator] Initial state:", {
        useAutoGenerated: result.useAutoGenerated,
        extensionEnabled: result.extensionEnabled,
        finalEnabled: this.isEnabled
      })

      // State loaded - processing will happen automatically via persistent monitor
    } catch (error) {
      console.error("[YouTube Manipulator] Failed to load initial state:", error)
      this.isEnabled = false
    }
  }

  private async loadWordCardStyles(): Promise<void> {
    try {
      const response = await new Promise<any>((resolve, reject) => {
        chrome.runtime.sendMessage(
          { action: "getWordCardStyles" },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError)
            } else {
              resolve(response)
            }
          }
        )
      })
      
      if (response && response.styles) {
        this.wordCardStyles = response.styles
        console.log("[YouTube Manipulator] Loaded WordCard styles:", this.wordCardStyles)
        this.renderWordCard()
      }
    } catch (error) {
      console.error("[YouTube Manipulator] Failed to load WordCard styles:", error)
    }
  }

  private async getUseAutoGeneratedSubtitles(): Promise<{
    useAutoGenerated: boolean
    extensionEnabled: boolean
  }> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== "undefined" && chrome.runtime) {
        chrome.runtime.sendMessage(
          { action: "getUseAutoGeneratedSubtitles" },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError)
            } else if (!response) {
              reject(new Error("No response from background script"))
            } else {
              resolve({
                useAutoGenerated: response.useAutoGenerated || false,
                extensionEnabled: response.extensionEnabled !== false
              })
            }
          }
        )
      } else {
        reject(new Error("Chrome runtime not available"))
      }
    })
  }

  private async initializeJapanese(): Promise<void> {
    try {
      // Initialize kuromoji tokenizer
      if (!window.kuromojiTokenizer) {
        const tokenizer = await new Promise<any>((resolve, reject) => {
          kuromoji
            .builder({
              dicPath: chrome.runtime.getURL("node_modules/kuromoji/dict/")
            })
            .build((err, tokenizer) => {
              if (err) {
                reject(err)
                return
              }
              resolve(tokenizer)
            })
        })
        window.kuromojiTokenizer = tokenizer
        console.log("[YouTube Manipulator] Kuromoji tokenizer loaded")
      }

      // Set up progress callback for dictionary loading
      dictionaryDB.onProgress((progress, total) => {
        showLoadingOverlay(progress, total)
      })

      // Initialize dictionary database (singleton, loads JSON once if needed)
      await dictionaryDB.initialize()
      console.log("[YouTube Manipulator] Dictionary database ready")
      
      // Hide loading overlay when done
      hideLoadingOverlay()

      this.isInitialized = true
      console.log("[YouTube Manipulator] Japanese processing ready - will process captions automatically")
    } catch (error) {
      console.error("[YouTube Manipulator] Failed to initialize Japanese processing:", error)
      hideLoadingOverlay()
      this.isInitialized = false
    }
  }

  // New: Persistent monitoring that always runs
  private async startPersistentMonitoring(): Promise<void> {
    console.log("[YouTube Manipulator] Setting up persistent monitoring")
    
    // Wait for page to be ready
    if (document.readyState !== 'complete') {
      await new Promise(resolve => window.addEventListener('load', resolve, { once: true }))
    }
    
    console.log("[YouTube Manipulator] Page ready, starting monitoring")
    
    // Setup UI components
    this.createReactWordCard()
    this.observeNavigation()
    
    // Check every 500ms if we should process captions
    this.updateInterval = setInterval(() => {
      // Only process if: enabled + initialized + on watch page
      if (!this.isEnabled || !this.isInitialized) return
      if (!window.location.href.includes("youtube.com/watch")) return
      
      const captionContainer = document.querySelector(".captions-text")
      if (!captionContainer) return
      
      // Lazy setup: only create observers when captions exist
      if (!this.captionObserver) {
        this.addSubtitleHoverListeners()
        this.observeCaptionContainerChanges(captionContainer)
      }
      
      // Ensure word card exists
      if (!this.wordCardContainer || !document.getElementById("bundai-youtube-wordcard-root")) {
        this.createReactWordCard()
      }
      
      const currentText = this.getCaptionText()
      
      // Check if segments need processing
      const segments = document.querySelectorAll(".ytp-caption-segment")
      let needsReprocessing = false
      
      segments.forEach(segment => {
        const hasTokenizedWords = segment.querySelector('.tokenized-word')
        const hasJapaneseText = segment.textContent && this.isJapaneseText(segment.textContent)
        
        if (hasJapaneseText && !hasTokenizedWords) {
          needsReprocessing = true
        }
      })
      
      if (needsReprocessing) {
        this.processCaptionSegments()
      }
      
      if (currentText && currentText !== this.lastCaptionText && this.isJapaneseText(currentText)) {
        this.lastCaptionText = currentText
        this.processCaptionSegments()
      }
    }, 500)
    
    console.log("[YouTube Manipulator] Persistent monitoring active")
  }

  private createReactWordCard(): void {
    if (document.getElementById("bundai-youtube-wordcard-root")) {
      document.getElementById("bundai-youtube-wordcard-root")?.remove()
    }

    this.wordCardContainer = document.createElement("div")
    this.wordCardContainer.id = "bundai-youtube-wordcard-root"
    this.wordCardContainer.className = "react-word-card-container"

    document.body.appendChild(this.wordCardContainer)

    this.wordCardRoot = createRoot(this.wordCardContainer)
    this.renderWordCard()
  }

  private renderWordCard(): void {
    if (!this.wordCardRoot || !this.wordCardContainer) return
  
    const captionContainer = document.querySelector(".captions-text")
    const containerRect = captionContainer?.getBoundingClientRect() || null
  
    this.wordCardRoot.render(
      <WordCard
        word={this.wordCard.word}
        mouseX={this.wordCard.mouseX}
        mouseY={this.wordCard.mouseY}
        isVisible={this.wordCard.isVisible}
        isSticky={this.wordCard.isSticky}
        onClose={this.handleCardClose.bind(this)}
        containerRect={containerRect}
        customStyles={this.wordCardStyles}
      />
    )
  }

  private handleCardClose(): void {
    this.wordCard = {
      ...this.wordCard,
      isVisible: false,
      isSticky: false,
      word: ""
    }
    this.renderWordCard()
  }


  // ✅ NEW: Observe caption container for changes (Solution 1)
  private observeCaptionContainerChanges(captionContainer: Element): void {
    if (this.captionObserver) {
      this.captionObserver.disconnect()
    }

    this.captionObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
          // Check if the caption container itself was replaced
          const currentContainer = document.querySelector(".captions-text")
          
          if (currentContainer && currentContainer !== captionContainer) {
            console.log("[YouTube Manipulator] Caption container replaced, reattaching observer")
            this.observeCaptionContainerChanges(currentContainer)
            return
          }
          
          // Force re-process current text when container structure changes
          const currentText = this.getCaptionText()
          if (currentText && this.isJapaneseText(currentText)) {
            // Check if current segments are tokenized
            const segments = document.querySelectorAll(".ytp-caption-segment")
            let hasUntokenized = false
            
            segments.forEach(segment => {
              const hasTokens = segment.querySelector('.tokenized-word')
              const hasJapanese = segment.textContent && this.isJapaneseText(segment.textContent)
              if (hasJapanese && !hasTokens) {
                hasUntokenized = true
              }
            })
            
            if (hasUntokenized) {
              console.log("[YouTube Manipulator] Container changed, re-tokenizing segments")
              this.lastCaptionText = "" // Reset to force reprocessing
              this.processCaptionSegments()
            }
          }
        }
      }
    })

    this.captionObserver.observe(captionContainer, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['style', 'class']
    })

    console.log("[YouTube Manipulator] Caption container observer attached")
  }

  // ✅ UPDATED: Use event delegation (Solution 2)
  private addSubtitleHoverListeners(): void {
    // Only attach once globally
    if (window.__bundaiHoverListenersAttached) {
      console.log("[YouTube Manipulator] Hover listeners already attached")
      return
    }

    const handleMouseEnter = (e: MouseEvent) => {
      const target = e.target as Element
      // Check if mouse entered caption area
      if (target.closest('.captions-text')) {
        const video = document.querySelector("video") as HTMLVideoElement
        if (video && typeof video.pause === "function") {
          video.pause()
        }
      }
    }

    const handleMouseLeave = (e: MouseEvent) => {
      const target = e.target as Element
      const relatedTarget = e.relatedTarget as Element
      
      // Check if we're actually leaving the caption area (not just moving between child elements)
      const leavingCaptions = target.closest('.captions-text') && !relatedTarget?.closest('.captions-text')
      
      if (leavingCaptions) {
        const video = document.querySelector("video") as HTMLVideoElement
        if (video && typeof video.play === "function") {
          video.play()
        }
      }
    }

    // Attach to document body with capture phase to catch all events
    document.body.addEventListener("mouseenter", handleMouseEnter, true)
    document.body.addEventListener("mouseleave", handleMouseLeave, true)
    
    window.__bundaiHoverListenersAttached = true
    console.log("[YouTube Manipulator] Hover listeners attached with event delegation")
  }

  private getCaptionText(): string | null {
    const captionContainer = document.querySelector(".captions-text")
    if (!captionContainer) return null

    const segments = captionContainer.querySelectorAll(".ytp-caption-segment")
    if (segments.length === 0) return null

    return Array.from(segments)
      .map((segment) => segment.textContent?.trim())
      .filter((text) => text && text.length > 0)
      .join(" ")
  }

  private processCaptionSegments(): void {
    const segments = document.querySelectorAll(".ytp-caption-segment")

    segments.forEach((segment) => {
      const text = segment.textContent
      if (!text || !this.isJapaneseText(text)) return

      // Check if already tokenized to avoid re-processing
      if (segment.querySelector('.tokenized-word')) {
        return
      }

      const tokens = this.tokenizeJapanese(text)
      if (tokens.length === 0) return

      const tempContainer = document.createElement("div")
      tempContainer.style.display = "contents"

      tempContainer.innerHTML = tokens
        .map(
          (token, index) =>
            `<span class="tokenized-word" data-word="${this.escapeHtml(token.surface_form)}" data-index="${index}">${this.escapeHtml(token.surface_form)}</span>`
        )
        .join("")

      tempContainer.querySelectorAll(".tokenized-word").forEach((wordElement) => {
        const word = wordElement.getAttribute("data-word")
        if (!word) return

        wordElement.addEventListener("mouseenter", (e) => {
          const rect = (e.target as HTMLElement).getBoundingClientRect()
          this.handleWordHover(word, rect.left + rect.width / 2, rect.top)
        })

        wordElement.addEventListener("mouseleave", () => {
          this.handleWordLeave()
        })

        wordElement.addEventListener("click", (e) => {
          e.stopPropagation()
          const rect = (e.target as HTMLElement).getBoundingClientRect()
          this.handleWordClick(word, rect.left + rect.width / 2, rect.top)
        })

        const htmlElement = wordElement as HTMLElement
        htmlElement.style.cursor = "pointer"
        htmlElement.style.padding = "2px 4px"
        htmlElement.style.borderRadius = "4px"
        htmlElement.style.transition = "background-color 0.2s"
        htmlElement.style.display = "inline"

        htmlElement.addEventListener("mouseenter", () => {
          htmlElement.style.backgroundColor = "rgba(255, 255, 255, 0.2)"
        })

        htmlElement.addEventListener("mouseleave", () => {
          htmlElement.style.backgroundColor = "transparent"
        })
      })

      segment.innerHTML = ""
      segment.appendChild(tempContainer)
    })
  }

  private escapeHtml(text: string): string {
    const div = document.createElement("div")
    div.textContent = text
    return div.innerHTML
  }

  private handleWordHover(word: string, mouseX: number, mouseY: number): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: false
    }
    this.renderWordCard()
  }

  private handleWordLeave(): void {
    if (!this.wordCard.isSticky) {
      this.wordCard.isVisible = false
      this.renderWordCard()
    }
  }

  private handleWordClick(word: string, mouseX: number, mouseY: number): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: true
    }
    this.renderWordCard()
  }

  private isJapaneseText(text: string): boolean {
    return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text)
  }

  private tokenizeJapanese(text: string): Token[] {
    if (!window.kuromojiTokenizer) return []
    return window.kuromojiTokenizer.tokenize(text)
  }

  private observeNavigation(): void {
    if (!this.isEnabled) return

    let currentUrl = window.location.href

    this.observer = new MutationObserver(() => {
      if (currentUrl !== window.location.href) {
        currentUrl = window.location.href
        this.lastCaptionText = ""
        this.wordCard = {
          word: "",
          mouseX: 0,
          mouseY: 0,
          isVisible: false,
          isSticky: false
        }
        this.renderWordCard()

        if (window.location.href.includes("youtube.com/watch")) {
          setTimeout(() => this.startMonitoring(), 1000)
        }
      }
    })

    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    })
  }

  public setEnabled(enabled: boolean): void {
    const wasEnabled = this.isEnabled
    this.isEnabled = enabled

    console.log(`[YouTube Manipulator] ${enabled ? "Enabled" : "Disabled"}`)

    if (!enabled && wasEnabled) {
      // When disabling, clean up tokenized captions
      this.cleanupTokenizedCaptions()
    }
    // When enabling, persistent monitor will automatically process captions
  }
  
  private cleanupTokenizedCaptions(): void {
    console.log("[YouTube Manipulator] Cleaning up tokenized captions")
    document.querySelectorAll(".ytp-caption-segment").forEach(segment => {
      const tokenized = segment.querySelectorAll('.tokenized-word')
      if (tokenized.length > 0) {
        // Restore original text
        const text = Array.from(tokenized).map(t => t.textContent).join('')
        segment.textContent = text
      }
    })
    this.lastCaptionText = ""
  }


  private cleanup(): void {
    // Cleanup caption observer
    if (this.captionObserver) {
      this.captionObserver.disconnect()
      this.captionObserver = null
    }

    this.lastCaptionText = ""
    this.wordCard = {
      word: "",
      mouseX: 0,
      mouseY: 0,
      isVisible: false,
      isSticky: false
    }

    // Note: We keep updateInterval, observer, and wordCard running
    // They're part of persistent monitoring
  }

  public destroy(): void {
    console.log("[YouTube Manipulator] Destroying instance")
    
    // Stop all monitoring
    if (this.updateInterval) {
      clearInterval(this.updateInterval)
      this.updateInterval = null
    }

    if (this.observer) {
      this.observer.disconnect()
      this.observer = null
    }

    if (this.captionObserver) {
      this.captionObserver.disconnect()
      this.captionObserver = null
    }

    if (this.wordCardRoot) {
      this.wordCardRoot.unmount()
      this.wordCardRoot = null
    }

    if (this.wordCardContainer) {
      this.wordCardContainer.remove()
      this.wordCardContainer = null
    }
    
    this.isEnabled = false
    this.isInitialized = false
    this.lastCaptionText = ""
    
    // Remove global hover listeners on complete destruction
    window.__bundaiHoverListenersAttached = false
  }
}

console.log("[YouTube Manipulator] Script loaded on:", window.location.href)

let youtubeManipulator: YouTubeSubtitleManipulator | null = null

if (window.top === window.self) {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeYouTubeManipulator)
  } else {
    initializeYouTubeManipulator()
  }
}

function initializeYouTubeManipulator() {
  if ((window as any).__bundaiYouTubeManipulatorInit) {
    console.log("[YouTube Manipulator] Already initialized, skipping")
    return
  }
  (window as any).__bundaiYouTubeManipulatorInit = true

  if (youtubeManipulator) {
    youtubeManipulator.destroy()
  }

  youtubeManipulator = new YouTubeSubtitleManipulator()
  console.log("[YouTube Manipulator] Instance created")
}

// Global message listener - works even during reinitialization
if (typeof chrome !== "undefined" && chrome.runtime) {
  console.log("[YouTube Manipulator] Registering global message listener")
  
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log("[YouTube Manipulator] Message received:", message.action)
    
    if (message.action === "setUseAutoGeneratedSubtitles") {
      console.log("[YouTube Manipulator] Processing setUseAutoGeneratedSubtitles:", message.useAutoGenerated)
      
      const wasEnabled = youtubeManipulator?.isEnabled
      const newEnabled = message.useAutoGenerated
      
      if (youtubeManipulator) {
        youtubeManipulator.setEnabled(newEnabled)
      }
      
      sendResponse({ success: true })
      return true
    }

    if (message.action === "getUseAutoGeneratedSubtitles") {
      sendResponse({ 
        useAutoGenerated: youtubeManipulator?.isEnabled || false 
      })
      return true
    }
    
    if (message.action === "setWordCardStyles") {
      console.log("[YouTube Manipulator] Processing setWordCardStyles:", message.styles)
      if (youtubeManipulator) {
        (youtubeManipulator as any).wordCardStyles = message.styles || {}
        // Call the private method to re-render
        if (typeof (youtubeManipulator as any).renderWordCard === 'function') {
          (youtubeManipulator as any).renderWordCard()
        }
      }
      sendResponse({ success: true })
      return true
    }
  })
}


let currentUrl = location.href
const urlObserver = new MutationObserver(() => {
  if (location.href !== currentUrl) {
    currentUrl = location.href
    console.log("[YouTube Manipulator] URL changed, reinitializing")

    // Cleanup existing instance before reinitializing
    if (youtubeManipulator) {
      youtubeManipulator.destroy()
      youtubeManipulator = null
    }

    // Shorter delay for navigation - state should be already available
    setTimeout(() => {
      (window as any).__bundaiYouTubeManipulatorInit = false
      initializeYouTubeManipulator()
    }, 500)
  }
})

urlObserver.observe(document.body, { childList: true, subtree: true })

window.addEventListener("beforeunload", () => {
  youtubeManipulator?.destroy()
  urlObserver.disconnect()
})

export { YouTubeSubtitleManipulator }