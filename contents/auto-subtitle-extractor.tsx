import cssText from "data-text:~style.css"
import type { PlasmoCSConfig } from "plasmo"
import kuromoji from "kuromoji"
import { createRoot } from "react-dom/client"
import React from "react"
import WordCard from "~components/WordCard"

export const getStyle = () => {
  const style = document.createElement("style")
  style.textContent = cssText
  return style
}

export const config: PlasmoCSConfig = {
  matches: ["*://*.youtube.com/watch*"],
  all_frames: false
}

interface Token {
  surface_form: string
}

interface JMDictEntry {
  kanji?: string[]
  kana?: string[]
  senses?: Array<{
    gloss: string[]
  }>
}

declare global {
  interface Window {
    jmdictData: JMDictEntry[]
    jmdictIndex: Record<string, JMDictEntry>
    jmdictKanaIndex: Record<string, JMDictEntry>
    jmdictLoaded: boolean
    kuromojiTokenizer: any
    __bundaiHoverListenersAttached?: boolean
  }
}

class YouTubeSubtitleManipulator {
  private isEnabled: boolean = false
  private isInitialized: boolean = false
  private lastCaptionText: string = ""
  private updateInterval: NodeJS.Timeout | null = null
  private observer: MutationObserver | null = null
  private captionObserver: MutationObserver | null = null // ✅ New observer for caption changes
  private wordCardContainer: HTMLDivElement | null = null
  private wordCardRoot: any = null
  private initializationAttempts: number = 0
  private maxInitAttempts: number = 5

  private wordCard: {
    word: string
    mouseX: number
    mouseY: number
    isVisible: boolean
    isSticky: boolean
  } = {
    word: "",
    mouseX: 0,
    mouseY: 0,
    isVisible: false,
    isSticky: false
  }

  constructor() {
    this.setupMessageListener()
    this.initializeJapanese()
    this.requestInitialState()
  }

  private async requestInitialState(): Promise<void> {
    console.log("[YouTube Manipulator] Requesting initial state from background...")
    
    // Only wait for page load if page is still loading
    if (document.readyState !== 'complete') {
      await new Promise(resolve => {
        window.addEventListener('load', resolve, { once: true })
      })
      // Only add delay on initial page load, not on navigation
      await new Promise(resolve => setTimeout(resolve, 1500))
    } else {
      // Page already loaded (navigation), request state immediately
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    
    await this.requestStateWithRetry()
  }

  private async requestStateWithRetry(attempt: number = 0): Promise<void> {
    try {
      const result = await this.getUseAutoGeneratedSubtitles()
      
      this.isEnabled = result.useAutoGenerated && result.extensionEnabled
      
      console.log("[YouTube Manipulator] State received:", {
        useAutoGenerated: result.useAutoGenerated,
        extensionEnabled: result.extensionEnabled,
        finalEnabled: this.isEnabled
      })

      if (this.isEnabled) {
        console.log("[YouTube Manipulator] Auto-generated mode enabled, initializing")
        this.init()
      } else {
        console.log("[YouTube Manipulator] Auto-generated mode disabled")
      }
    } catch (error) {
      console.error(`[YouTube Manipulator] Error getting state (attempt ${attempt + 1}/${this.maxInitAttempts}):`, error)
      
      if (attempt < this.maxInitAttempts - 1) {
        const delay = 500 * Math.pow(2, attempt)
        console.log(`[YouTube Manipulator] Retrying in ${delay}ms...`)
        await new Promise(resolve => setTimeout(resolve, delay))
        return this.requestStateWithRetry(attempt + 1)
      } else {
        console.error("[YouTube Manipulator] Failed to get state after all retries, assuming disabled")
        this.isEnabled = false
      }
    }
  }

  private async getUseAutoGeneratedSubtitles(): Promise<{
    useAutoGenerated: boolean
    extensionEnabled: boolean
  }> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== "undefined" && chrome.runtime) {
        chrome.runtime.sendMessage(
          { action: "getUseAutoGeneratedSubtitles" },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError)
            } else if (!response) {
              reject(new Error("No response from background script"))
            } else {
              resolve({
                useAutoGenerated: response.useAutoGenerated || false,
                extensionEnabled: response.extensionEnabled !== false
              })
            }
          }
        )
      } else {
        reject(new Error("Chrome runtime not available"))
      }
    })
  }

  private async initializeJapanese(): Promise<void> {
    try {
      if (!window.kuromojiTokenizer) {
        const tokenizer = await new Promise<any>((resolve, reject) => {
          kuromoji
            .builder({
              dicPath: chrome.runtime.getURL("node_modules/kuromoji/dict/")
            })
            .build((err, tokenizer) => {
              if (err) {
                reject(err)
                return
              }
              resolve(tokenizer)
            })
        })
        window.kuromojiTokenizer = tokenizer
      }

      if (!window.jmdictLoaded) {
        try {
          const response = await fetch(
            chrome.runtime.getURL(
              "assets/data/japanese/jmdict-simplified-flat-full.json"
            )
          )
          window.jmdictData = await response.json()
          window.jmdictIndex = {}
          window.jmdictKanaIndex = {}

          window.jmdictData.forEach((entry) => {
            if (Array.isArray(entry.kanji)) {
              entry.kanji.forEach((kanji) => {
                window.jmdictIndex[kanji] = entry
              })
            }
            if (Array.isArray(entry.kana)) {
              entry.kana.forEach((kana) => {
                window.jmdictKanaIndex[kana] = entry
              })
            }
          })

          window.jmdictLoaded = true
          console.log("[YouTube Manipulator] JMdict loaded:", window.jmdictData.length, "entries")
        } catch (e) {
          console.error("[YouTube Manipulator] Failed to load JMdict:", e)
          window.jmdictData = []
          window.jmdictIndex = {}
          window.jmdictKanaIndex = {}
          window.jmdictLoaded = true
        }
      }

      this.isInitialized = true
    } catch (error) {
      console.error("[YouTube Manipulator] Failed to initialize Japanese processing:", error)
      this.isInitialized = false
    }
  }

  private init(): void {
    if (!this.isEnabled) {
      console.log("[YouTube Manipulator] Not enabled, skipping initialization")
      return
    }

    if (!window.location.href.includes("youtube.com/watch")) {
      console.log("[YouTube Manipulator] Not on watch page")
      return
    }

    this.createReactWordCard()
    this.startMonitoring()
    this.observeNavigation()

    console.log("[YouTube Manipulator] Initialized")
  }

  private createReactWordCard(): void {
    if (document.getElementById("bundai-youtube-wordcard-root")) {
      document.getElementById("bundai-youtube-wordcard-root")?.remove()
    }

    this.wordCardContainer = document.createElement("div")
    this.wordCardContainer.id = "bundai-youtube-wordcard-root"
    this.wordCardContainer.className = "react-word-card-container"

    document.body.appendChild(this.wordCardContainer)

    this.wordCardRoot = createRoot(this.wordCardContainer)
    this.renderWordCard()
  }

  private renderWordCard(): void {
    if (!this.wordCardRoot || !this.wordCardContainer) return
  
    const captionContainer = document.querySelector(".captions-text")
    const containerRect = captionContainer?.getBoundingClientRect() || null
  
    this.wordCardRoot.render(
      <WordCard
        word={this.wordCard.word}
        mouseX={this.wordCard.mouseX}
        mouseY={this.wordCard.mouseY}
        isVisible={this.wordCard.isVisible}
        isSticky={this.wordCard.isSticky}
        onClose={this.handleCardClose.bind(this)}
        containerRect={containerRect}
      />
    )
  }

  private handleCardClose(): void {
    this.wordCard = {
      ...this.wordCard,
      isVisible: false,
      isSticky: false,
      word: ""
    }
    this.renderWordCard()
  }

  private startMonitoring(): void {
    if (!this.isEnabled || !this.isInitialized) return

    if (this.updateInterval) {
      clearInterval(this.updateInterval)
    }

    const captionContainer = document.querySelector(".captions-text")
    if (!captionContainer) {
      console.log("[YouTube Manipulator] No caption container found yet, retrying...")
      setTimeout(() => this.startMonitoring(), 1000)
      return
    }

    // ✅ Attach hover listeners with event delegation (Solution 2)
    this.addSubtitleHoverListeners()
    
    // ✅ Observe caption container for changes (Solution 1)
    this.observeCaptionContainerChanges(captionContainer)

    this.updateInterval = setInterval(() => {
      if (!window.location.href.includes("youtube.com/watch")) {
        if (this.updateInterval) {
          clearInterval(this.updateInterval)
          this.updateInterval = null
        }
        return
      }

      const currentText = this.getCaptionText()
      
      // ✅ Check if segments need reprocessing (Solution 3)
      const segments = document.querySelectorAll(".ytp-caption-segment")
      let needsReprocessing = false
      
      segments.forEach(segment => {
        const hasTokenizedWords = segment.querySelector('.tokenized-word')
        const hasJapaneseText = segment.textContent && this.isJapaneseText(segment.textContent)
        
        if (hasJapaneseText && !hasTokenizedWords) {
          needsReprocessing = true
        }
      })
      
      if (needsReprocessing) {
        console.log("[YouTube Manipulator] Detected un-tokenized segments, reprocessing...")
        this.processCaptionSegments()
      }
      
      if (currentText && currentText !== this.lastCaptionText && this.isJapaneseText(currentText)) {
        this.lastCaptionText = currentText
        this.processCaptionSegments()
      }
    }, 500)
  }

  // ✅ NEW: Observe caption container for changes (Solution 1)
  private observeCaptionContainerChanges(captionContainer: Element): void {
    if (this.captionObserver) {
      this.captionObserver.disconnect()
    }

    this.captionObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
          // Check if the caption container itself was replaced
          const currentContainer = document.querySelector(".captions-text")
          
          if (currentContainer && currentContainer !== captionContainer) {
            console.log("[YouTube Manipulator] Caption container replaced, reattaching observer")
            this.observeCaptionContainerChanges(currentContainer)
            return
          }
          
          // Force re-process current text when container structure changes
          const currentText = this.getCaptionText()
          if (currentText && this.isJapaneseText(currentText)) {
            // Check if current segments are tokenized
            const segments = document.querySelectorAll(".ytp-caption-segment")
            let hasUntokenized = false
            
            segments.forEach(segment => {
              const hasTokens = segment.querySelector('.tokenized-word')
              const hasJapanese = segment.textContent && this.isJapaneseText(segment.textContent)
              if (hasJapanese && !hasTokens) {
                hasUntokenized = true
              }
            })
            
            if (hasUntokenized) {
              console.log("[YouTube Manipulator] Container changed, re-tokenizing segments")
              this.lastCaptionText = "" // Reset to force reprocessing
              this.processCaptionSegments()
            }
          }
        }
      }
    })

    this.captionObserver.observe(captionContainer, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['style', 'class']
    })

    console.log("[YouTube Manipulator] Caption container observer attached")
  }

  // ✅ UPDATED: Use event delegation (Solution 2)
  private addSubtitleHoverListeners(): void {
    // Only attach once globally
    if (window.__bundaiHoverListenersAttached) {
      console.log("[YouTube Manipulator] Hover listeners already attached")
      return
    }

    const handleMouseEnter = (e: MouseEvent) => {
      const target = e.target as Element
      // Check if mouse entered caption area
      if (target.closest('.captions-text')) {
        const video = document.querySelector("video") as HTMLVideoElement
        if (video && typeof video.pause === "function") {
          video.pause()
        }
      }
    }

    const handleMouseLeave = (e: MouseEvent) => {
      const target = e.target as Element
      const relatedTarget = e.relatedTarget as Element
      
      // Check if we're actually leaving the caption area (not just moving between child elements)
      const leavingCaptions = target.closest('.captions-text') && !relatedTarget?.closest('.captions-text')
      
      if (leavingCaptions) {
        const video = document.querySelector("video") as HTMLVideoElement
        if (video && typeof video.play === "function") {
          video.play()
        }
      }
    }

    // Attach to document body with capture phase to catch all events
    document.body.addEventListener("mouseenter", handleMouseEnter, true)
    document.body.addEventListener("mouseleave", handleMouseLeave, true)
    
    window.__bundaiHoverListenersAttached = true
    console.log("[YouTube Manipulator] Hover listeners attached with event delegation")
  }

  private getCaptionText(): string | null {
    const captionContainer = document.querySelector(".captions-text")
    if (!captionContainer) return null

    const segments = captionContainer.querySelectorAll(".ytp-caption-segment")
    if (segments.length === 0) return null

    return Array.from(segments)
      .map((segment) => segment.textContent?.trim())
      .filter((text) => text && text.length > 0)
      .join(" ")
  }

  private processCaptionSegments(): void {
    const segments = document.querySelectorAll(".ytp-caption-segment")

    segments.forEach((segment) => {
      const text = segment.textContent
      if (!text || !this.isJapaneseText(text)) return

      // Check if already tokenized to avoid re-processing
      if (segment.querySelector('.tokenized-word')) {
        return
      }

      const tokens = this.tokenizeJapanese(text)
      if (tokens.length === 0) return

      const tempContainer = document.createElement("div")
      tempContainer.style.display = "contents"

      tempContainer.innerHTML = tokens
        .map(
          (token, index) =>
            `<span class="tokenized-word" data-word="${this.escapeHtml(token.surface_form)}" data-index="${index}">${this.escapeHtml(token.surface_form)}</span>`
        )
        .join("")

      tempContainer.querySelectorAll(".tokenized-word").forEach((wordElement) => {
        const word = wordElement.getAttribute("data-word")
        if (!word) return

        wordElement.addEventListener("mouseenter", (e) => {
          const rect = (e.target as HTMLElement).getBoundingClientRect()
          this.handleWordHover(word, rect.left + rect.width / 2, rect.top)
        })

        wordElement.addEventListener("mouseleave", () => {
          this.handleWordLeave()
        })

        wordElement.addEventListener("click", (e) => {
          e.stopPropagation()
          const rect = (e.target as HTMLElement).getBoundingClientRect()
          this.handleWordClick(word, rect.left + rect.width / 2, rect.top)
        })

        const htmlElement = wordElement as HTMLElement
        htmlElement.style.cursor = "pointer"
        htmlElement.style.padding = "2px 4px"
        htmlElement.style.borderRadius = "4px"
        htmlElement.style.transition = "background-color 0.2s"
        htmlElement.style.display = "inline"

        htmlElement.addEventListener("mouseenter", () => {
          htmlElement.style.backgroundColor = "rgba(255, 255, 255, 0.2)"
        })

        htmlElement.addEventListener("mouseleave", () => {
          htmlElement.style.backgroundColor = "transparent"
        })
      })

      segment.innerHTML = ""
      segment.appendChild(tempContainer)
    })
  }

  private escapeHtml(text: string): string {
    const div = document.createElement("div")
    div.textContent = text
    return div.innerHTML
  }

  private handleWordHover(word: string, mouseX: number, mouseY: number): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: false
    }
    this.renderWordCard()
  }

  private handleWordLeave(): void {
    if (!this.wordCard.isSticky) {
      this.wordCard.isVisible = false
      this.renderWordCard()
    }
  }

  private handleWordClick(word: string, mouseX: number, mouseY: number): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: true
    }
    this.renderWordCard()
  }

  private isJapaneseText(text: string): boolean {
    return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text)
  }

  private tokenizeJapanese(text: string): Token[] {
    if (!window.kuromojiTokenizer) return []
    return window.kuromojiTokenizer.tokenize(text)
  }

  private observeNavigation(): void {
    if (!this.isEnabled) return

    let currentUrl = window.location.href

    this.observer = new MutationObserver(() => {
      if (currentUrl !== window.location.href) {
        currentUrl = window.location.href
        this.lastCaptionText = ""
        this.wordCard = {
          word: "",
          mouseX: 0,
          mouseY: 0,
          isVisible: false,
          isSticky: false
        }
        this.renderWordCard()

        if (window.location.href.includes("youtube.com/watch")) {
          setTimeout(() => this.startMonitoring(), 1000)
        }
      }
    })

    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    })
  }

  public setEnabled(enabled: boolean): void {
    const wasEnabled = this.isEnabled
    this.isEnabled = enabled

    console.log(`[YouTube Manipulator] ${enabled ? "Enabled" : "Disabled"}`)

    if (enabled && !wasEnabled) {
      this.init()
    } else if (!enabled && wasEnabled) {
      this.cleanup()
    }
  }

  private setupMessageListener(): void {
    if (typeof chrome !== "undefined" && chrome.runtime) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (message.action === "setUseAutoGeneratedSubtitles") {
          this.setEnabled(message.useAutoGenerated)
          sendResponse({ success: true })
        }

        if (message.action === "getUseAutoGeneratedSubtitles") {
          sendResponse({ useAutoGenerated: this.isEnabled })
        }
      })
    }
  }

  private cleanup(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval)
      this.updateInterval = null
    }

    if (this.observer) {
      this.observer.disconnect()
      this.observer = null
    }

    // ✅ Cleanup caption observer
    if (this.captionObserver) {
      this.captionObserver.disconnect()
      this.captionObserver = null
    }

    if (this.wordCardRoot) {
      this.wordCardRoot.unmount()
      this.wordCardRoot = null
    }

    if (this.wordCardContainer) {
      this.wordCardContainer.remove()
      this.wordCardContainer = null
    }

    this.lastCaptionText = ""
    this.wordCard = {
      word: "",
      mouseX: 0,
      mouseY: 0,
      isVisible: false,
      isSticky: false
    }

    // Note: We don't remove global hover listeners as they should persist
    // across enable/disable cycles
  }

  public destroy(): void {
    this.cleanup()
    this.isEnabled = false
    this.isInitialized = false
    
    // Remove global hover listeners on complete destruction
    window.__bundaiHoverListenersAttached = false
  }
}

let youtubeManipulator: YouTubeSubtitleManipulator | null = null

if (window.top === window.self) {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeYouTubeManipulator)
  } else {
    initializeYouTubeManipulator()
  }
}

function initializeYouTubeManipulator() {
  if ((window as any).__bundaiYouTubeManipulatorInit) {
    return
  }
  (window as any).__bundaiYouTubeManipulatorInit = true

  if (youtubeManipulator) {
    youtubeManipulator.destroy()
  }

  youtubeManipulator = new YouTubeSubtitleManipulator()
  console.log("[YouTube Manipulator] YouTube subtitle manipulator initialized")
}

if (typeof chrome !== "undefined" && chrome.runtime) {
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === "autoGeneratedToggled") {
      if (youtubeManipulator) {
        youtubeManipulator.setEnabled(message.useAutoGenerated)
      }
      sendResponse({ success: true })
    }
  })
}

let currentUrl = location.href
const urlObserver = new MutationObserver(() => {
  if (location.href !== currentUrl) {
    currentUrl = location.href
    console.log("[YouTube Manipulator] URL changed, reinitializing")

    // Cleanup existing instance before reinitializing
    if (youtubeManipulator) {
      youtubeManipulator.destroy()
      youtubeManipulator = null
    }

    // Shorter delay for navigation - state should be already available
    setTimeout(() => {
      (window as any).__bundaiYouTubeManipulatorInit = false
      initializeYouTubeManipulator()
    }, 500)
  }
})

urlObserver.observe(document.body, { childList: true, subtree: true })

window.addEventListener("beforeunload", () => {
  youtubeManipulator?.destroy()
  urlObserver.disconnect()
})

export { YouTubeSubtitleManipulator }