import { ApolloProvider, useMutation } from "@apollo/client"
import cssText from "data-text:~style.css"
import kuromoji from "kuromoji"
import type { PlasmoCSConfig } from "plasmo"
import React, { useEffect, useRef, useState } from "react"
import { createRoot } from "react-dom/client"
import { toRomaji } from "wanakana"

import DictionaryLoadingOverlay from "../components/DictionaryLoadingOverlay"
import WordCard from "../components/WordCard"
import client from "../graphql"
import { ADD_FLASH_CARD_MUTATION } from "../graphql/mutations/addFlashCard.mutation"
import dictionaryDB from "../services/dictionaryDB"

export const getStyle = () => {
  const style = document.createElement("style")
  style.textContent = cssText
  return style
}

export const config: PlasmoCSConfig = {
  matches: ["*://*.youtube.com/watch*"],
  all_frames: false
}

export interface SubtitleCue {
  start: number
  end: number
  text: string
}

interface SubtitleSettings {
  subtitle1: {
    fontSize: number
    color: string
    backgroundColor: string
    opacity: number
  }
  subtitle2: {
    fontSize: number
    color: string
    backgroundColor: string
    opacity: number
  }
  position: number
  gap: number
}

interface WordCardStyles {
  backgroundColor?: string
  textColor?: string
  fontSize?: number
  borderRadius?: number
  borderColor?: string
  wordFontSize?: number
}

interface Token {
  surface_form: string
}

declare global {
  interface Window {
    kuromojiTokenizer: any
  }
}

// Global loading overlay manager
let loadingOverlayContainer: HTMLDivElement | null = null
let loadingOverlayRoot: any = null

function showLoadingOverlay(progress: number, total: number) {
  if (!loadingOverlayContainer) {
    loadingOverlayContainer = document.createElement("div")
    loadingOverlayContainer.id = "bundai-loading-overlay-root"
    document.body.appendChild(loadingOverlayContainer)
    loadingOverlayRoot = createRoot(loadingOverlayContainer)
  }

  loadingOverlayRoot.render(
    <DictionaryLoadingOverlay
      progress={progress}
      total={total}
      isVisible={true}
    />
  )
}

function hideLoadingOverlay() {
  if (loadingOverlayRoot) {
    loadingOverlayRoot.render(
      <DictionaryLoadingOverlay progress={0} total={0} isVisible={false} />
    )
    setTimeout(() => {
      if (loadingOverlayRoot) {
        loadingOverlayRoot.unmount()
        loadingOverlayRoot = null
      }
      if (loadingOverlayContainer) {
        loadingOverlayContainer.remove()
        loadingOverlayContainer = null
      }
    }, 300)
  }
}

class CustomSubtitleContainer {
  private videoElement: HTMLVideoElement | null = null
  private subtitleContainer: HTMLDivElement | null = null
  private subtitle1Element: HTMLDivElement | null = null
  private subtitle2Element: HTMLDivElement | null = null
  private wordCardContainer: HTMLDivElement | null = null
  private wordCardRoot: any = null
  private updateInterval: NodeJS.Timeout | null = null
  private observer: MutationObserver | null = null
  private isEnabled: boolean = false
  private initializationAttempts: number = 0
  private maxInitAttempts: number = 5

  private settings: SubtitleSettings = {
    subtitle1: {
      fontSize: 24,
      color: "#ffffff",
      backgroundColor: "#000000",
      opacity: 0.8
    },
    subtitle2: {
      fontSize: 20,
      color: "#ffffff",
      backgroundColor: "#000000",
      opacity: 0.8
    },
    position: 15,
    gap: 10
  }

  private subtitle1Data: SubtitleCue[] = []
  private subtitle2Data: SubtitleCue[] = []
  private subtitle1Url: string | null = null
  private subtitle2Url: string | null = null

  private autoGeneratedSubtitles: SubtitleCue[] = []

  private lastProcessedSubtitle1Text: string = ""
  private lastProcessedSubtitle2Text: string = ""

  private wordCard: {
    word: string
    mouseX: number
    mouseY: number
    isVisible: boolean
    isSticky: boolean
  } = {
    word: "",
    mouseX: 0,
    mouseY: 0,
    isVisible: false,
    isSticky: false
  }

  private isJapaneseEnabled: boolean = true
  private isInitialized: boolean = false
  private wordCardStyles: WordCardStyles = {}

  constructor() {
    this.setupMessageListener()
    this.initializeJapanese()
    this.requestInitialState()
    this.setupAutoSubtitleListener()
    // Delay style loading to ensure background is ready
    setTimeout(() => this.loadWordCardStyles(), 500)
  }

  private async loadWordCardStyles(): Promise<void> {
    try {
      const response = await new Promise<any>((resolve, reject) => {
        chrome.runtime.sendMessage(
          { action: "getWordCardStyles" },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError)
            } else {
              resolve(response)
            }
          }
        )
      })

      if (response && response.styles) {
        this.wordCardStyles = response.styles
        console.log(
          "[Custom Subtitles] Loaded WordCard styles:",
          this.wordCardStyles
        )
        this.renderWordCard()
      }
    } catch (error) {
      console.error("[Custom Subtitles] Failed to load WordCard styles:", error)
    }
  }

  /**
   * Request the initial state from background script with retry logic
   */
  private async requestInitialState(): Promise<void> {
    console.log(
      "[Custom Subtitles] Requesting initial state from background..."
    )

    // Only wait for page load if page is still loading
    if (document.readyState !== "complete") {
      await new Promise((resolve) => {
        window.addEventListener("load", resolve, { once: true })
      })
      // Only add delay on initial page load, not on navigation
      await new Promise((resolve) => setTimeout(resolve, 1500))
    } else {
      // Page already loaded (navigation), request state immediately
      await new Promise((resolve) => setTimeout(resolve, 100))
    }

    await this.requestStateWithRetry()
  }

  /**
   * Request state with exponential backoff retry
   */
  private async requestStateWithRetry(attempt: number = 0): Promise<void> {
    try {
      const result = await this.getExtensionEnabledState()

      // API mode is enabled when extension is on AND reader mode is off
      this.isEnabled =
        result.extensionEnabled && !result.universalReaderEnabled

      console.log("[Custom Subtitles] State received:", {
        extensionEnabled: result.extensionEnabled,
        universalReaderEnabled: result.universalReaderEnabled,
        finalEnabled: this.isEnabled
      })

      if (this.isEnabled) {
        console.log(
          "[Custom Subtitles] Custom subtitle mode enabled, initializing"
        )
        this.init()
      } else {
        console.log("[Custom Subtitles] Custom subtitle mode disabled")
      }
    } catch (error) {
      console.error(
        `[Custom Subtitles] Error getting state (attempt ${attempt + 1}/${this.maxInitAttempts}):`,
        error
      )

      if (attempt < this.maxInitAttempts - 1) {
        const delay = 500 * Math.pow(2, attempt)
        console.log(`[Custom Subtitles] Retrying in ${delay}ms...`)
        await new Promise((resolve) => setTimeout(resolve, delay))
        return this.requestStateWithRetry(attempt + 1)
      } else {
        console.error(
          "[Custom Subtitles] Failed to get state after all retries, assuming disabled"
        )
        this.isEnabled = false
      }
    }
  }

  /**
   * Get state from background script
   * API mode is enabled when extensionEnabled && !universalReaderEnabled
   */
  private async getExtensionEnabledState(): Promise<{
    extensionEnabled: boolean
    universalReaderEnabled: boolean
  }> {
    return new Promise((resolve, reject) => {
      if (typeof chrome !== "undefined" && chrome.runtime) {
        chrome.runtime.sendMessage(
          { action: "getUniversalReaderEnabled" },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError)
            } else if (!response) {
              reject(new Error("No response from background script"))
            } else {
              resolve({
                extensionEnabled: response.extensionEnabled !== false,
                universalReaderEnabled: response.universalReaderEnabled || false
              })
            }
          }
        )
      } else {
        reject(new Error("Chrome runtime not available"))
      }
    })
  }

  private async initializeJapanese(): Promise<void> {
    try {
      // Initialize kuromoji tokenizer
      if (!window.kuromojiTokenizer) {
        const tokenizer = await new Promise<any>((resolve, reject) => {
          kuromoji
            .builder({
              dicPath: chrome.runtime.getURL("node_modules/kuromoji/dict/")
            })
            .build((err, tokenizer) => {
              if (err) {
                reject(err)
                return
              }
              resolve(tokenizer)
            })
        })
        window.kuromojiTokenizer = tokenizer
        console.log("[Custom Subtitles] Kuromoji tokenizer loaded")
      }

      // Set up progress callback for dictionary loading
      dictionaryDB.onProgress((progress, total) => {
        showLoadingOverlay(progress, total)
      })

      // Initialize dictionary database (singleton, loads JSON once if needed)
      await dictionaryDB.initialize()
      console.log("[Custom Subtitles] Dictionary database ready")

      // Hide loading overlay when done
      hideLoadingOverlay()

      this.isInitialized = true
    } catch (error) {
      console.error(
        "[Custom Subtitles] Failed to initialize Japanese processing:",
        error
      )
      hideLoadingOverlay()
      this.isInitialized = false
    }
  }

  private init(): void {
    if (!this.isEnabled) {
      console.log(
        "[Custom Subtitles] Extension disabled, skipping initialization"
      )
      return
    }

    this.findAndSetupVideo()

    if (!this.videoElement) {
      this.observeForVideo()
    }
  }

  private findAndSetupVideo(): void {
    if (!this.isEnabled) return

    const videos = document.querySelectorAll(
      "video"
    ) as NodeListOf<HTMLVideoElement>

    if (videos.length > 0) {
      let targetVideo = Array.from(videos).find(
        (video) =>
          video.classList.contains("html5-main-video") ||
          video.closest(".html5-video-player")
      )

      if (!targetVideo) {
        targetVideo = Array.from(videos).reduce((largest, current) => {
          const largestArea = largest.offsetWidth * largest.offsetHeight
          const currentArea = current.offsetWidth * current.offsetHeight
          return currentArea > largestArea ? current : largest
        })
      }

      if (targetVideo && targetVideo !== this.videoElement) {
        this.videoElement = targetVideo
        this.setupSubtitleContainer()
        console.log(
          "[Custom Subtitles] Video element found and subtitles setup"
        )
      }
    }
  }

  private observeForVideo(): void {
    if (!this.isEnabled) return

    this.observer = new MutationObserver((mutations) => {
      if (this.videoElement || !this.isEnabled) return

      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          const addedNodes = Array.from(mutation.addedNodes) as Element[]
          for (const node of addedNodes) {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const videos = (node as Element).querySelectorAll?.("video") || []
              if (videos.length > 0 || (node as Element).tagName === "VIDEO") {
                this.findAndSetupVideo()
                if (this.videoElement) {
                  this.observer?.disconnect()
                  return
                }
              }
            }
          }
        }
      }
    })

    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    })
  }

  private setupSubtitleContainer(): void {
    if (!this.videoElement || !this.isEnabled) return

    document
      .querySelectorAll(
        ".custom-subtitle-container, .react-word-card-container, #bundai-subtitle-root, #bundai-wordcard-root"
      )
      .forEach((el) => el.remove())
    this.removeSubtitleContainer()

    if (document.getElementById("bundai-subtitle-root")) {
      return
    }

    this.subtitleContainer = document.createElement("div")
    this.subtitleContainer.id = "bundai-subtitle-root"
    this.subtitleContainer.className = "custom-subtitle-container"
    this.subtitleContainer.style.cssText = `
      position: fixed;
      left: 50%;
      bottom: ${this.settings.position}%;
      transform: translateX(-50%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: ${this.settings.gap}px;
      pointer-events: auto;
      max-width: 80%;
      min-width: 300px;
    `

    this.subtitle1Element = document.createElement("div")
    this.subtitle1Element.className = "custom-subtitle subtitle-1"
    this.applySubtitleStyles(this.subtitle1Element, this.settings.subtitle1)
    this.subtitleContainer.appendChild(this.subtitle1Element)

    this.subtitle2Element = document.createElement("div")
    this.subtitle2Element.className = "custom-subtitle subtitle-2"
    this.applySubtitleStyles(this.subtitle2Element, this.settings.subtitle2)
    this.subtitleContainer.appendChild(this.subtitle2Element)

    this.createReactWordCard()

    document.body.appendChild(this.subtitleContainer)

    this.startSubtitleUpdates()

    console.log("[Custom Subtitles] Subtitle container created and positioned")

    // âœ… AUTO-LOAD: Load saved subtitle selections automatically
    this.loadSavedSubtitles()
  }

  public setEnabled(enabled: boolean): void {
    const wasEnabled = this.isEnabled
    this.isEnabled = enabled

    console.log(
      `[Custom Subtitles] Extension ${enabled ? "enabled" : "disabled"}`
    )

    if (enabled && !wasEnabled) {
      this.init()
    } else if (!enabled && wasEnabled) {
      this.removeSubtitleContainer()
      this.observer?.disconnect()
      this.observer = null
      this.videoElement = null

      this.lastProcessedSubtitle1Text = ""
      this.lastProcessedSubtitle2Text = ""

      this.wordCard = {
        word: "",
        mouseX: 0,
        mouseY: 0,
        isVisible: false,
        isSticky: false
      }
    }
  }

  private createReactWordCard(): void {
    if (document.getElementById("bundai-wordcard-root")) {
      document.getElementById("bundai-wordcard-root")?.remove()
    }
    this.wordCardContainer = document.createElement("div")
    this.wordCardContainer.id = "bundai-wordcard-root"
    this.wordCardContainer.className = "react-word-card-container"

    document.body.appendChild(this.wordCardContainer)

    this.wordCardRoot = createRoot(this.wordCardContainer)
    this.renderWordCard()
  }

  private renderWordCard(): void {
    if (!this.wordCardRoot || !this.wordCardContainer) return

    const containerRect =
      this.subtitleContainer?.getBoundingClientRect() || null

    this.wordCardRoot.render(
      <WordCardManager
        wordCard={this.wordCard}
        containerRect={containerRect}
        onClose={this.handleCardClose.bind(this)}
        customStyles={this.wordCardStyles}
      />
    )
  }

  private handleCardClose(): void {
    this.wordCard = {
      ...this.wordCard,
      isVisible: false,
      isSticky: false,
      word: ""
    }
    this.renderWordCard()
  }

  private applySubtitleStyles(
    element: HTMLDivElement,
    subtitleSettings: any
  ): void {
    element.style.cssText = `
      background: ${this.hexToRgba(subtitleSettings.backgroundColor, subtitleSettings.opacity)};
      color: ${subtitleSettings.color};
      font-size: ${subtitleSettings.fontSize}px;
      font-family: Arial, sans-serif;
      font-weight: bold;
      padding: 8px 16px;
      border-radius: 6px;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      line-height: 1.3;
      min-height: 20px;
      display: none;
      word-wrap: break-word;
      max-width: 100%;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      cursor: default;
    `
  }

  private hexToRgba(hex: string, opacity: number): string {
    const r = parseInt(hex.slice(1, 3), 16)
    const g = parseInt(hex.slice(3, 5), 16)
    const b = parseInt(hex.slice(5, 7), 16)
    return `rgba(${r}, ${g}, ${b}, ${opacity})`
  }

  private startSubtitleUpdates(): void {
    if (!this.isEnabled) return

    if (this.updateInterval) {
      clearInterval(this.updateInterval)
    }

    this.updateInterval = setInterval(() => {
      this.updateSubtitles()
    }, 100)
  }

  private updateSubtitles(): void {
    if (
      !this.videoElement ||
      !this.subtitle1Element ||
      !this.subtitle2Element ||
      !this.isEnabled
    )
      return

    const currentTime = this.videoElement.currentTime

    const subtitle1Cue = this.subtitle1Data.find(
      (cue) => currentTime >= cue.start && currentTime <= cue.end
    )

    if (subtitle1Cue) {
      this.subtitle1Element.style.display = "block"
      if (subtitle1Cue.text !== this.lastProcessedSubtitle1Text) {
        this.lastProcessedSubtitle1Text = subtitle1Cue.text
        this.processSubtitleElement(this.subtitle1Element, subtitle1Cue.text)
      }
    } else {
      this.subtitle1Element.style.display = "none"
      if (this.lastProcessedSubtitle1Text !== "") {
        this.lastProcessedSubtitle1Text = ""
        this.subtitle1Element.textContent = ""
      }
    }

    const subtitle2Cue = this.subtitle2Data.find(
      (cue) => currentTime >= cue.start && currentTime <= cue.end
    )

    if (subtitle2Cue) {
      this.subtitle2Element.style.display = "block"
      if (subtitle2Cue.text !== this.lastProcessedSubtitle2Text) {
        this.lastProcessedSubtitle2Text = subtitle2Cue.text
        this.processSubtitleElement(this.subtitle2Element, subtitle2Cue.text)
      }
    } else {
      this.subtitle2Element.style.display = "none"
      if (this.lastProcessedSubtitle2Text !== "") {
        this.lastProcessedSubtitle2Text = ""
        this.subtitle2Element.textContent = ""
      }
    }
  }

  private processSubtitleElement(element: HTMLDivElement, text: string): void {
    if (
      !this.isJapaneseEnabled ||
      !this.isInitialized ||
      !this.isJapaneseText(text)
    ) {
      element.textContent = text
      return
    }

    const tokens = this.tokenizeJapanese(text)
    if (tokens.length === 0) {
      element.textContent = text
      return
    }

    const tempContainer = document.createElement("div")
    tempContainer.style.display = "contents"

    tempContainer.innerHTML = tokens
      .map(
        (token, index) =>
          `<span class="tokenized-word" data-word="${this.escapeHtml(token.surface_form)}" data-index="${index}">${this.escapeHtml(token.surface_form)}</span>`
      )
      .join("")

    tempContainer.querySelectorAll(".tokenized-word").forEach((wordElement) => {
      const word = wordElement.getAttribute("data-word")
      if (!word) return

      wordElement.addEventListener("mouseenter", (e) => {
        const rect = (e.target as HTMLElement).getBoundingClientRect()
        this.handleWordHover(word, rect.left + rect.width / 2, rect.top)
      })

      wordElement.addEventListener("mouseleave", () => {
        this.handleWordLeave()
      })

      wordElement.addEventListener("click", (e) => {
        e.stopPropagation()
        const rect = (e.target as HTMLElement).getBoundingClientRect()
        this.handleWordClick(word, rect.left + rect.width / 2, rect.top)
      })

      const htmlElement = wordElement as HTMLElement
      htmlElement.style.cursor = "pointer"
      htmlElement.style.padding = "2px 4px"
      htmlElement.style.borderRadius = "4px"
      htmlElement.style.transition = "background-color 0.2s"
      htmlElement.style.display = "inline"

      htmlElement.addEventListener("mouseenter", () => {
        htmlElement.style.backgroundColor = "rgba(255, 255, 255, 0.2)"
      })

      htmlElement.addEventListener("mouseleave", () => {
        htmlElement.style.backgroundColor = "transparent"
      })
    })

    element.innerHTML = ""
    element.appendChild(tempContainer)

    element.addEventListener(
      "mouseenter",
      this.handleSubtitleMouseEnter.bind(this)
    )
    element.addEventListener(
      "mouseleave",
      this.handleSubtitleMouseLeave.bind(this)
    )
  }

  private escapeHtml(text: string): string {
    const div = document.createElement("div")
    div.textContent = text
    return div.innerHTML
  }

  private handleSubtitleMouseEnter(): void {
    if (this.videoElement && typeof this.videoElement.pause === "function") {
      this.videoElement.pause()
    }
  }

  private handleSubtitleMouseLeave(): void {
    if (this.videoElement && typeof this.videoElement.play === "function") {
      this.videoElement.play()
    }
  }

  private handleWordHover(word: string, mouseX: number, mouseY: number): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: false
    }
    this.renderWordCard()
  }

  private handleWordLeave(): void {
    if (!this.wordCard.isSticky) {
      this.wordCard.isVisible = false
      this.renderWordCard()
    }
  }

  private handleWordClick(word: string, mouseX: number, mouseY: number): void {
    this.wordCard = {
      word,
      mouseX,
      mouseY,
      isVisible: true,
      isSticky: true
    }
    this.renderWordCard()
  }

  private isJapaneseText(text: string): boolean {
    return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text)
  }

  private tokenizeJapanese(text: string): Token[] {
    if (!window.kuromojiTokenizer) return []
    return window.kuromojiTokenizer.tokenize(text)
  }

  private removeSubtitleContainer(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval)
      this.updateInterval = null
    }

    if (this.subtitleContainer) {
      this.subtitleContainer.remove()
      this.subtitleContainer = null
      this.subtitle1Element = null
      this.subtitle2Element = null
    }

    if (this.wordCardRoot) {
      this.wordCardRoot.unmount()
      this.wordCardRoot = null
    }

    if (this.wordCardContainer) {
      this.wordCardContainer.remove()
      this.wordCardContainer = null
    }

    this.lastProcessedSubtitle1Text = ""
    this.lastProcessedSubtitle2Text = ""

    this.wordCard = {
      word: "",
      mouseX: 0,
      mouseY: 0,
      isVisible: false,
      isSticky: false
    }
  }

  // Continue with remaining methods...
  public updateSettings(newSettings: Partial<SubtitleSettings>): void {
    this.settings = { ...this.settings, ...newSettings }

    if (this.subtitleContainer && this.isEnabled) {
      this.subtitleContainer.style.bottom = `${this.settings.position}%`
      this.subtitleContainer.style.gap = `${this.settings.gap}px`
    }

    if (this.subtitle1Element && this.isEnabled) {
      this.applySubtitleStyles(this.subtitle1Element, this.settings.subtitle1)
    }

    if (this.subtitle2Element && this.isEnabled) {
      this.applySubtitleStyles(this.subtitle2Element, this.settings.subtitle2)
    }
  }

  public updateSubtitleData(
    subtitle1Data?: SubtitleCue[],
    subtitle2Data?: SubtitleCue[]
  ): void {
    if (subtitle1Data) {
      this.subtitle1Data = subtitle1Data
      this.lastProcessedSubtitle1Text = ""
    }
    if (subtitle2Data) {
      this.subtitle2Data = subtitle2Data
      this.lastProcessedSubtitle2Text = ""
    }
  }

  public async loadSubtitleFromUrl(
    url: string,
    trackNumber: 1 | 2
  ): Promise<void> {
    if (!this.isEnabled) {
      console.log(
        "[Custom Subtitles] Extension disabled, not loading subtitles"
      )
      return
    }

    try {
      console.log(
        `[Custom Subtitles] Loading subtitle ${trackNumber} from:`,
        url
      )

      if (trackNumber === 1) {
        this.subtitle1Url = url
      } else {
        this.subtitle2Url = url
      }

      const response = await fetch(url)
      const subtitleText = await response.text()

      const parsedSubtitles = this.parseSubtitleText(subtitleText)

      if (trackNumber === 1) {
        this.subtitle1Data = parsedSubtitles
        this.lastProcessedSubtitle1Text = ""
        console.log(
          `[Custom Subtitles] Loaded ${parsedSubtitles.length} cues for subtitle 1`
        )
      } else {
        this.subtitle2Data = parsedSubtitles
        this.lastProcessedSubtitle2Text = ""
        console.log(
          `[Custom Subtitles] Loaded ${parsedSubtitles.length} cues for subtitle 2`
        )
      }
    } catch (error) {
      console.error(
        `[Custom Subtitles] Error loading subtitle ${trackNumber}:`,
        error
      )
    }
  }

  private parseSubtitleText(subtitleText: string): SubtitleCue[] {
    const cues: SubtitleCue[] = []

    if (subtitleText.includes("WEBVTT")) {
      return this.parseVTT(subtitleText)
    } else if (subtitleText.match(/^\d+\s*$/m)) {
      return this.parseSRT(subtitleText)
    }

    return cues
  }

  private parseVTT(vttText: string): SubtitleCue[] {
    const cues: SubtitleCue[] = []
    const lines = vttText.split("\n")

    let i = 0
    while (i < lines.length) {
      const line = lines[i].trim()

      if (line.includes("-->")) {
        const timeMatch = line.match(
          /(\d{2}:)?(\d{2}):(\d{2})\.(\d{3})\s*-->\s*(\d{2}:)?(\d{2}):(\d{2})\.(\d{3})/
        )

        if (timeMatch) {
          const startTime = this.parseTimeToSeconds(
            timeMatch[0].split("-->")[0].trim()
          )
          const endTime = this.parseTimeToSeconds(
            timeMatch[0].split("-->")[1].trim()
          )

          i++
          let text = ""
          while (i < lines.length && lines[i].trim() !== "") {
            if (text) text += " "
            text += lines[i].trim()
            i++
          }

          if (text) {
            cues.push({
              start: startTime,
              end: endTime,
              text: text.replace(/<[^>]*>/g, "")
            })
          }
        }
      }
      i++
    }

    return cues
  }

  private parseSRT(srtText: string): SubtitleCue[] {
    const cues: SubtitleCue[] = []
    const blocks = srtText.split(/\n\s*\n/)

    for (const block of blocks) {
      const lines = block.trim().split("\n")
      if (lines.length >= 3) {
        const timeMatch = lines[1].match(
          /(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/
        )

        if (timeMatch) {
          const startTime = this.parseTimeToSeconds(
            lines[1].split("-->")[0].trim().replace(",", ".")
          )
          const endTime = this.parseTimeToSeconds(
            lines[1].split("-->")[1].trim().replace(",", ".")
          )

          const text = lines
            .slice(2)
            .join(" ")
            .replace(/<[^>]*>/g, "")

          cues.push({
            start: startTime,
            end: endTime,
            text: text
          })
        }
      }
    }

    return cues
  }

  private parseTimeToSeconds(timeStr: string): number {
    const parts = timeStr.match(/(?:(\d{2}):)?(\d{2}):(\d{2})[\.,](\d{3})/)
    if (!parts) return 0

    const hours = parseInt(parts[1] || "0")
    const minutes = parseInt(parts[2])
    const seconds = parseInt(parts[3])
    const milliseconds = parseInt(parts[4])

    return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000
  }

  private setupMessageListener(): void {
    if (typeof chrome !== "undefined" && chrome.runtime) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (message.action === "loadSubtitle") {
          this.loadSubtitleFromUrl(message.url, message.trackNumber)
            .then(() => sendResponse({ success: true }))
            .catch((error) =>
              sendResponse({ success: false, error: error.message })
            )
          return true
        }

        if (message.action === "updateSettings") {
          this.updateSettings(message.settings)
          sendResponse({ success: true })
        }

        if (message.action === "setJapaneseEnabled") {
          this.isJapaneseEnabled = message.enabled
          sendResponse({ success: true })
        }

        if (message.action === "setExtensionEnabled") {
          console.log(
            "[Custom Subtitles] Received setExtensionEnabled:",
            message.enabled
          )
          this.setEnabled(message.enabled)
          sendResponse({ success: true })
          return true
        }

        if (message.action === "getExtensionState") {
          sendResponse({ enabled: this.isEnabled })
          return true
        }

        if (message.action === "setWordCardStyles") {
          console.log(
            "[Custom Subtitles] Processing setWordCardStyles:",
            message.styles
          )
          this.wordCardStyles = message.styles || {}
          this.renderWordCard()
          sendResponse({ success: true })
          return true
        }
      })
    }

    window.addEventListener("loadSubtitle", (event: CustomEvent) => {
      if (!this.isEnabled) return
      const { url, trackNumber } = event.detail
      this.loadSubtitleFromUrl(url, trackNumber)
    })

    window.addEventListener(
      "persistSubtitleSelection",
      (event: CustomEvent) => {
        if (!this.isEnabled) return
        const { subtitle1Url, subtitle2Url } = event.detail
        if (subtitle1Url) this.loadSubtitleFromUrl(subtitle1Url, 1)
        if (subtitle2Url) this.loadSubtitleFromUrl(subtitle2Url, 2)
      }
    )
  }

  private setupAutoSubtitleListener(): void {
    window.addEventListener("autoSubtitleExtracted", (event: CustomEvent) => {
      const { cue, language, isAutoGenerated } = event.detail

      if (isAutoGenerated) {
        this.autoGeneratedSubtitles.push(cue)

        if (this.autoGeneratedSubtitles.length > 500) {
          this.autoGeneratedSubtitles = this.autoGeneratedSubtitles.slice(-250)
        }

        console.log(`[Custom Subtitles] Auto-generated subtitle: "${cue.text}"`)
      }
    })
  }

  public getAutoGeneratedSubtitles(): SubtitleCue[] {
    return [...this.autoGeneratedSubtitles]
  }

  public destroy(): void {
    this.observer?.disconnect()
    this.removeSubtitleContainer()
    this.videoElement = null
    this.isInitialized = false
    this.isEnabled = false
  }

  public getCurrentSubtitleUrls(): {
    subtitle1Url: string | null
    subtitle2Url: string | null
  } {
    return {
      subtitle1Url: this.subtitle1Url,
      subtitle2Url: this.subtitle2Url
    }
  }

  public async loadSavedSubtitles(): Promise<void> {
    if (!this.isEnabled) {
      console.log(
        "[Custom Subtitles] loadSavedSubtitles: Not enabled, skipping"
      )
      return
    }

    try {
      const videoId = this.extractVideoId(window.location.href)
      if (!videoId) {
        console.log("[Custom Subtitles] loadSavedSubtitles: No video ID found")
        return
      }

      // Use the same keys as SubtitlesSection component
      const result = await chrome.storage.local.get([
        `subtitle1_${videoId}`,
        `subtitle2_${videoId}`
      ])

      const subtitle1Url = result[`subtitle1_${videoId}`]
      const subtitle2Url = result[`subtitle2_${videoId}`]

      console.log("[Custom Subtitles] Saved subtitle URLs:", {
        subtitle1Url,
        subtitle2Url
      })

      if (subtitle1Url || subtitle2Url) {
        if (subtitle1Url) {
          await this.loadSubtitleFromUrl(subtitle1Url, 1)
          console.log("[Custom Subtitles] Auto-loaded subtitle 1")
        }
        if (subtitle2Url) {
          await this.loadSubtitleFromUrl(subtitle2Url, 2)
          console.log("[Custom Subtitles] Auto-loaded subtitle 2")
        }
      } else {
        console.log(
          "[Custom Subtitles] No saved subtitles found for this video"
        )
      }
    } catch (error) {
      console.error("[Custom Subtitles] Failed to load saved subtitles:", error)
    }
  }

  private extractVideoId(url: string): string | null {
    if (!url) return null

    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&?/]+)/i,
      /youtube\.com\/watch.*?[?&]v=([^&?/]+)/i
    ]

    for (const pattern of patterns) {
      const match = url.match(pattern)
      if (match && match[1]) {
        return match[1]
      }
    }

    return null
  }
}

const WordCardManager: React.FC<{
  wordCard: {
    word: string
    mouseX: number
    mouseY: number
    isVisible: boolean
    isSticky: boolean
  }
  containerRect: DOMRect | null
  onClose: () => void
  customStyles?: WordCardStyles
}> = ({ wordCard, containerRect, onClose, customStyles }) => {
  return (
    <WordCard
      word={wordCard.word}
      mouseX={wordCard.mouseX}
      mouseY={wordCard.mouseY}
      isVisible={wordCard.isVisible}
      isSticky={wordCard.isSticky}
      onClose={onClose}
      containerRect={containerRect}
      customStyles={customStyles}
    />
  )
}

let subtitleContainer: CustomSubtitleContainer | null = null

// Track initial state to detect changes
let initialEnabled: boolean | null = null

if (window.top === window.self) {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeSubtitles)
  } else {
    initializeSubtitles()
  }
}

async function initializeSubtitles() {
  if ((window as any).__bundaiSubtitleInit) {
    return
  }
  ;(window as any).__bundaiSubtitleInit = true

  if (subtitleContainer) {
    subtitleContainer.destroy()
  }

  subtitleContainer = new CustomSubtitleContainer()

  // Store initial enabled state
  if (initialEnabled === null) {
    initialEnabled = subtitleContainer.isEnabled
  }

  console.log("[Custom Subtitles] Subtitle system initialized")
}

// Global message listener for state changes
if (typeof chrome !== "undefined" && chrome.runtime) {
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === "setExtensionEnabled") {
      const newEnabled = message.enabled
      const wasEnabled = subtitleContainer?.isEnabled

      if (subtitleContainer) {
        subtitleContainer.setEnabled(newEnabled)
      }

      sendResponse({ success: true })
      return true
    }

    if (message.action === "setWordCardStyles") {
      console.log(
        "[Custom Subtitles Global] Processing setWordCardStyles:",
        message.styles
      )
      if (subtitleContainer) {
        ;(subtitleContainer as any).wordCardStyles = message.styles || {}
        // Call the private method to re-render
        if (typeof (subtitleContainer as any).renderWordCard === "function") {
          ;(subtitleContainer as any).renderWordCard()
        }
      }
      sendResponse({ success: true })
      return true
    }
  })
}

let currentUrl = location.href
const urlObserver = new MutationObserver(() => {
  if (location.href !== currentUrl) {
    currentUrl = location.href
    console.log("[Custom Subtitles] URL changed, reinitializing subtitles")

    // Cleanup existing instance before reinitializing
    if (subtitleContainer) {
      subtitleContainer.destroy()
      subtitleContainer = null
    }

    // Shorter delay for navigation - state should be already available
    setTimeout(() => {
      ;(window as any).__bundaiSubtitleInit = false
      initializeSubtitles()
    }, 500)
  }
})

urlObserver.observe(document.body, { childList: true, subtree: true })

window.addEventListener("beforeunload", () => {
  subtitleContainer?.destroy()
  urlObserver.disconnect()
})

export { CustomSubtitleContainer }
